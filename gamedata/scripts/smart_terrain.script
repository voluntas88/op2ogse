-- -*- mode: lua; coding: windows-1251-dos -*-
--[=[
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--]=]

local check_period
if not editor() then
  check_period = game.CTime()
  check_period:setHMSms( 0, 0, 0, 50000 )
  CTime_0 = game.CTime()
end

local monster_classes
local disagreed, agreed, agreed_exclusive = 0, 1, 2
local smart_section = "smart_terrains"
local smart_terrains = {}
local smart_terrains_by_name = {}
exclusives = {}

--[=[
список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
  smart_terrains = {
    level_name = { id=obj, id=obj, ... },
    level_name = { id=obj, id=obj, ... },
    ...
  }
--]=]


--------------------------------------------------------------------------------
-- Разные полезные функции
--------------------------------------------------------------------------------
-------------- помощники для чтения ini (custom data) -------------------
-- TODO убрать их
function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end

function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end

function r_2nums( spawn_ini, section, line, def1, def2 )
  if spawn_ini:line_exist( section, line ) then
    -- если default-ов больше, чем значений в ini, то забить
    -- недостающие последним значением из ini
    local t = parse_nums( spawn_ini:r_string( section, line ) )
    local n = table.getn( t )
    if n == 0 then
      return def1, def2
    elseif n == 1 then
      return t[ 1 ], def2
    else
      return t[ 1 ], t[ 2 ]
    end
  else
    return def1, def2
  end
end


--------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
--------------------------------------------------------------------------------
class "se_smart_terrain"( cse_alife_smart_zone )
function se_smart_terrain:__init( section ) super( section )
  self.initialized = false
  self.registred   = false
end


function se_smart_terrain:detect_probability()
  return 0
end


function se_smart_terrain:print()
  log1( "NPCs:" )
  if self.npc_info then
    for id, v in pairs( self.npc_info ) do
      log2( "    %d %s", id, tostring( v.name ) )
    end
  end
end


-- сохранение
function se_smart_terrain:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )
  utils.w_CTime( packet, self.duration_end )
  utils.w_CTime( packet, self.idle_end     )
  if self.gulag_working then
    packet:w_bool( true )
    self.gulag:save_common( packet )
    local n = 0
    for id, v in pairs( self.npc_info ) do
      n = n + 1
    end
    packet:w_u8( n )
    for id, v in pairs( self.npc_info ) do
      packet:w_u16( id )
      packet:w_u8( v.o_group )
      packet:w_u8( v.o_squad )
      packet:w_bool( v.exclusive )
      utils.w_CTime( packet, v.stay_end )
      self.gulag:save_obj( packet, id )
    end
    packet:w_bool ( self.population_locked )
  else
    packet:w_bool( false )
  end
end


-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )
  self:read_params()
  -- под LevelEditor не пытаться читать из пакета ничего
  if editor() then
    return
  end
  self.duration_end  = utils.r_CTime( packet )
  self.idle_end      = utils.r_CTime( packet )
  self.gulag_working = packet:r_bool()
  -- если есть работающий гулаг
  if self.gulag_working then
    self.check_time = CTime_0
    self.gulag:load_common( packet )
    local n = packet:r_u8()
    for i = 1, n do
      local o_id = packet:r_u16()
      self.npc_info[ o_id ] = {}
      dsh.remember_mobs_smart_terrain( o_id, self, true )
      local o = self.npc_info[ o_id ]
      o.o_group   = packet:r_u8()
      o.o_squad   = packet:r_u8()
      o.exclusive = packet:r_bool()
      o.stay_end  = utils.r_CTime( packet )
      self.gulag:load_obj( packet, o_id )
    end
    self.population_locked = packet:r_bool()
  end
end


-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()
function se_smart_terrain:initialize_if_needed()
  if not self.initialized then
    self:get_se_objs()
    self:preserve_exclusives()
    self.gulag:reinit_job_online()
    self.initialized = true
  end
end


-- зарезервировать места для эксклюзивных персонажей
function se_smart_terrain:preserve_exclusives()
  local e = exclusives[ self:name() ]
  if e then
    self.exclusives = e
    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e
    exclusives[ self:name() ] = nil
  else
    self.exclusives = 0
  end
end


-- получить серверные объекты персонажей
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local del = {}
  for id, v in pairs( self.npc_info ) do
    local obj = sim:object( id )
    if obj then
      self:fill_npc_info( obj, v )
    else
      log2(
        "[smart_terrain %s] can't get server object id=%d", self:name(), id
      )
      table.insert( del, id )
    end
  end
  for _, id in ipairs( del ) do
    self.npc_info[ id ] = nil
    self.gulag:removeObject( id )
  end
end


-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
  if not npc_info then
    npc_info = {}
  end
  npc_info.se_obj       = obj
  npc_info.class_id     = obj:clsid()
  npc_info.section_name = obj:section_name()
  npc_info.name         = obj:name()
  npc_info.story_id     = obj.m_story_id
  npc_info.community    = self:get_obj_community( obj )
  npc_info.profile_name = obj.profile_name and obj:profile_name()
  npc_info.rank         = obj:rank()
  npc_info.group        = obj:g_group()
  npc_info.squad        = obj:g_squad()
  npc_info.team         = obj:g_team()
  if npc_info.profile_name then
    npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
  end
  npc_info.is_sniper_name = string.find( npc_info.name, "sniper" ) ~= nil
  local t               = obj.smart_terrain_conditions
  if t then
    t = t[ self:name() ]
  end
  npc_info.cond         = t
  return npc_info
end


-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
function se_smart_terrain:get_obj_community( obj )
  local cls = obj:clsid()
  if cls == clsid.script_stalker then
    return obj:community(), true
  else
    return monster_classes[ cls ], false
  end
end


-- инициализация.
-- чтение custom data.
function se_smart_terrain:read_params()
  local ini  = self:spawn_ini()
  local sect = "smart_terrain"
  if ini:section_exist( "dsh" ) then
    self.dsh_active_profile = get_string( "dsh", "active_profile", nil, ini )
  end
  if not ini:section_exist( sect ) then
    sect = "gulag1"
    if not ini:section_exist( sect ) then
      log2( "[smart_terrain %s] no configuration!", self:name() )
      self.disabled = true
      return
    end
  end
  if not ini:line_exist( sect, "type" ) then
    abort( "[smart_terrain %s] type is not specified", self:name() )
  end
  local gp       = {}
  self.npc_info  = {}           -- group и squad для каждого npc
  self.gparams   = gp           -- настройки гулага
  gp.type        = get_string( sect, "type",   nil, ini )
  gp.preset_name = get_string( sect, "preset", nil, ini )
  -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
  gp.capacity    = get_float( sect, "capacity", 100, ini )
  gp.squad       = get_float( sect, "squad", nil, ini )
  gp.idle_min, gp.idle_max = r_2nums( ini, sect, "idle", 0, 0 )
  gp.duration_min, gp.duration_max = r_2nums(
    ini, sect, "duration", 10000, 10001
  )
  gp.stay_min, gp.stay_max = smart_terrain_params.get_stay_time_interval(
    get_string( sect, "stay", "default", ini )
  )
  gp.respawn = get_string( sect, "respawn", nil, ini )
  gp.cond    = get_string( sect, "cond",    nil, ini )
  gp.groups  = get_string( sect, "groups",  nil, ini )
  self.rank_inc_min = get_string( "smart_terrain_rank_change", "min" )
  self.rank_inc_max = get_string( "smart_terrain_rank_change", "max" )
  self.accepted_communities = nil
  self.communities = get_string( sect, "communities", nil, ini )

  self:init_idle_times()
  self:dsh_override_params()

  if gp.cond then
    gp.cond = xr_logic.parse_condlist( nil, sect, "cond", gp.cond )
  end

  if gp.groups then
    gp.groups = parse_nums( gp.groups )
  end

  if self.communities then
    local comms = parse_names( self.communities )
    self.accepted_communities = {}
    for i, v in ipairs( comms ) do
      self.accepted_communities[ v ] = true
    end
  end

  self.population_locked = false
  self.gulag = xr_gulag.gulag(
    self, self.gparams.type, self.gparams.squad, self.gparams.groups,
    self.npc_info, self.gparams.capacity
  )
  self.gulag_working = false
end


function se_smart_terrain:init_idle_times()
  function parse_idle_time( sect, name )
    local val = get_string( sect, name )
    if val then
      val = parse_nums( val )
      if table.getn( val ) < 2 then
        table.insert( val, val[ 1 ] )
      end
    end
    return val
  end
  for _, suf in ipairs({ "." .. self:name(), "" }) do
    local sect = "dsh.gulag.idle" .. suf
    if sys_ini:section_exist( sect ) then
      self.idle_time_stalker = parse_idle_time( sect, "stalker" )
      self.idle_time_monster = parse_idle_time( sect, "monster" )
      break
    end
  end
end


function se_smart_terrain:dsh_override_params()
  if not dsh.is_gulag_fixes_enabled() then return end
  local dsh_override_opts = {
    [ "capacity" ] = {
      [ "getter" ] = function( ... ) return get_float(  ... ) end,
      [ "setter" ] = function( v ) self.gparams.capacity = v end,
    },
    [ "communities" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.communities = v end,
    },
    [ "cond" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.gparams.cond = v end,
    },
    [ "stay" ] = {
      [ "getter" ] = function( ... ) return get_numbers( ... ) end,
      [ "setter" ] = function( v )
        self.gparams.stay_min = v[ 1 ]
        if table.getn( v ) > 1 then
          self.gparams.stay_max = v[ 2 ]
        else
          self.gparams.stay_max = v[ 1 ]
        end
      end,
    },
    [ "type" ] = {
      [ "getter" ] = function( ... ) return get_string( ... ) end,
      [ "setter" ] = function( v ) self.gparams.type = v end,
    },
  }
  local dsh_sect = "dsh.gulag.override." .. self:name()
  local profile  = self.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  if sys_ini:section_exist( sect ) then
    for k, v in pairs( dsh_override_opts ) do
      if sys_ini:line_exist( sect, k ) then
        local value = v.getter( sect, k )
        v.setter( value )
      end
    end
  end
end


-- подходит ли персонаж по предустановкам.
-- если такой предустановки нету, то он всегда подходит.
function se_smart_terrain:check_preset( npc_community, npc_rank, preset_name )
  local preset = smart_terrain_params.get_preset( preset_name )
  if preset == false then
    return true
  else
    local t = preset[ npc_community ]
    if t and ( npc_rank >= t[ 1 ] and npc_rank <= t[ 2 ] ) then
      return true
    else
      return false
    end
  end
end


--[=[
подходит ли объект гулагу?

1) если объект не согласен сюда идти, то smart terrain его не возьмёт

2) если объект согласен идти куда угодно, то проверить, есть ли ещё
   места, подходит ли он гулагу, подходит ли он хоть на одну работу

3) если объект согласен идти только в этот смарт, то принимаем даже
   если нету места (он вытеснит кого-то), проверить, подходит ли он
   гулагу, подходит ли он хоть на одну работу
--]=]

-- таблица level_groups задаёт что-то вроде карты, где локации сгруппированы в области.
--
-- Неписи пойдут в смарт с другого уровня, только если этот уровень
-- находится в одной группе со смартом.
--
-- Вероятно, надо глянуть на карту и убедиться, что эти группы заданы
-- осмысленно.  как минимум, группы должны обеспечивать связность
-- графа в пределах локаций одной группы, и также надо согласовывать
-- место спавна неписей и группы, иначе заспавненные неписи не смогут
-- попасть в свой смарт.
--
-- если локация не прописана в этой таблице, то она будет
-- автоматически изолирована.
local level_groups = {
  [ "atp_for_test22" ] = "group1",
  [ "aver"           ] = "group1",
  [ "dead_city"      ] = "group1",
  [ "generators"     ] = "group1",
  [ "hospital"       ] = "group1",
  [ "limansk"        ] = "group1",
  [ "lost_village"   ] = "group1",
  [ "puzir"          ] = "group1",
  [ "red_forest"     ] = "group1",
  [ "warlab"         ] = "group1",

  [ "l01_escape"     ] = "group1",
  [ "l02_garbage"    ] = "group1",
  [ "l03_agroprom"   ] = "group1",
  [ "l03u_agr_underground" ] = "group1",
  [ "l04_darkvalley" ] = "group1",
  [ "l04u_labx18"    ] = "group1",
  [ "l05_bar"        ] = "group1",
  [ "l06_rostok"     ] = "group1",
  [ "l07_military"   ] = "group1",
  [ "l08_yantar"     ] = "group1",
  [ "l08u_brainlab"  ] = "group1",
  [ "l10_radar"      ] = "group1",
  [ "l10u_bunker"    ] = "group1",
  [ "l11_pripyat"    ] = "group1",
  [ "marsh"          ] = "group1",

  [ "l12_stancia"    ] = "group3",
  [ "l12u_sarcofag"  ] = "group3",
  [ "l12u_control_monolith" ] = "group3",
  [ "l12_stancia_2"  ] = "group3",

  [ "jupiter"        ] = "group4",
  [ "jupiter_underground" ] = "group4",
  [ "labx8"          ] = "group4",
  [ "pripyat"        ] = "group4",
  [ "zaton"          ] = "group4",
}


function is_same_level_group( l1, l2 )
  local g1 = level_groups[ l1 ] or l1
  local g2 = level_groups[ l2 ] or l2
  return g1 == g2
end


--[=[
Подходит ли объект гулагу.
Второй аргумент - результат работы функии obj_accepts_smart_terrain - тип
согласия объекта на вступление в этот смарт.
--]=]
--вызывается как часть enabled
function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
  if obj_agreement == disagreed then -- объект в этот смарт идти не хочет
    return false
  end
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return false
  end

  -- в любом случае, если хочет идти только в этот, или если готов без
  -- условий и при этом гулаг не заполнен полностью
  if
    obj_agreement == agreed_exclusive
    or self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
  then
    local community, is_stalker = self:get_obj_community( obj )
    -- фантомов не принимаем никуда
    if not community then return false end
    -- мертвых не принимаем тоже
    if not obj:alive() then return false end
    --' Проверка что смарттеррейн и НПС находятся в одном кластере
    --уровней (чтобы не ходили через БАР)
    local npc_level_group = ""
    if game_graph():valid_vertex_id( obj.m_game_vertex_id ) then
      npc_level_group = object_level_name( obj )
    end
    if not is_same_level_group( self:get_level_name(), npc_level_group ) then
      return false -- с этого уровня в этот смарт идти нельзя
    end
    -- если в кастомдате смарта есть перечень допустимых группировок и
    -- непись не попадает в эту группировку
    if
      self.accepted_communities and not self.accepted_communities[ community ]
   then
      return false              -- то не подходит
    end
    -- выполнить проверку, заданную скриптом для конкретного уровня
    -- (обычно соответствие типа гулага и параметров непися)
    if not xr_gulag.checkNpc(
      community, is_stalker, self.gparams.type, obj:rank(), obj, self
    ) then
      return false
    end
    -- если есть работа
    return self.gulag:is_there_any_suitable_job(
      self:fill_npc_info( obj ), obj_agreement == agreed_exclusive
    )
  else
    -- если не эксклюзив для этого смарта и места нет, то не подходит
    return false
  end
end


--[=[
подходит ли гулаг объекту?

у объекта в custom data прописаны условия для некоторых smart_terrains:
        <smart_terrain_name1> = <condlist1>
        <smart_terrain_name2> = <condlist2>
        ...
Если для какого-то smart_terrain условие выполнилось, он называется
эксклюзивным.
Если у объекта появился хоть один эксклюзивный smart terrain, то он будет
согласен идти только в него.
Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
Функция возвращает одно из трёх значений:
disagreed        - в этот не идёт
agreed_exclusive - идёт только в этот
agreed           - согласен идти в этот на неэкслюзивной основе
--]=]
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist
function se_smart_terrain:obj_accepts_smart_terrain( obj )
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return disagreed
  end

  -- если вообще есть какие-то специальные условия насчёт смартов
  if obj.smart_terrain_conditions then
    -- перебираем все варианты условий из секции непися
    --
    -- TODO: зачем перебирать условия для всех смартов, если можно по
    -- ключу выбрать только условие для этого?
    if xr_logic.pick_section_from_condlist(
      db.actor_proxy, obj, obj.smart_terrain_conditions[ "none" ]
    ) then
      return disagreed -- явно прописано, что не идёт ни в какой смарт
    else
      local condlist = obj.smart_terrain_conditions[ self:name() ]
      if condlist then          -- есть условие для этого смарта
        if xr_logic.pick_section_from_condlist(
          db.actor_proxy, obj, condlist
        ) then
          return agreed_exclusive -- идёт только в этот смарт
        end
      end
    end
    return disagreed            -- в этот не идёт
  end

  -- здесь имеем: эксклюзивов нет, явного запрета тоже нет
  --
  -- Если объекту запрещено переходить в online и эксклюзивные '
  -- смарты недоступны, то не пускаем его никуда. Это исключает '
  -- переброску отключенных до (или после) определённого события '
  -- людей и мутантов в другой неэксклюзивный смарт.
  if
    obj.spawner
    and xr_logic.pick_section_from_condlist(
      db.actor, obj, obj.spawner
    ) == nil
  then
    return disagreed
  end

  return agreed
end


-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в
-- группе вернут true
function se_smart_terrain:enabled( obj )
  if self.disabled then
    return false
  end
  if xr_companion.is_companion( obj.id ) then
    return false
  end

  -- если всё это делаем в первый раз проинитим ...вообще-то это
  -- должно с гарантией происходить при создании смарта движком,
  self:register_if_needed()
  self:initialize_if_needed()   -- но на всякий случай...

  -- если гулаг активен (по cond_list из кастомдаты смарта) и не
  -- заблокировано добавление персонажей
  if self:is_gulag_available() then
    -- если смарт подходит неписю
    local b = self:obj_accepts_smart_terrain( obj )
    if
      self.population_locked
      or ogse_st_mgr.timer_exists(
        "smart_terrain." .. self:name() .. ".population_locked"
      )
    then
      -- если гулаг заблокирован, то принимать только экслюзивных
      -- неписей
      return b == agreed_exclusive
    else
      -- и непись подходит смарту
      local a = self:smart_terrain_accepts_obj( obj, b )
      return a
    end
  else
    return false
  end
end


-- возвращает меру подходящести персонажа смарттерейну.
--
-- вызывается для всех смарттерейнов, которые вернули true из enabled
--
-- для того, чтобы выбрать тот единственный, в который персонаж
-- всё-таки пойдёт.  критерии:
--
--   1) если объект уже бывал в других смартах, то чем больше
--   свободных работ на уровне этого смарта, тем лучше
--
--   2) иначе ближе - лучше
--
-- TODO Оптимизировать
--
-- на основе это функции принимается решение для непися (не смарта),
-- т.е. здесь непись выбирает себе смарт для какого смарта число
-- больше, туда и пойдёт
function se_smart_terrain:suitable( obj )
  -- это компаньон, нечего ему в смарте делать
  if xr_companion.is_companion( obj.id ) then
    return 0
  end
  -- Повысить подходящесть эксклюзивного смарттеррейна
  if self:obj_accepts_smart_terrain( obj ) == agreed_exclusive then
    -- некрасиво, уже ведь проверяли, а фунция некислая
    -- TODO: оптимизировать
    -- v = 100000 --'Так чтобы все эксклюзивные были заведомо лучше
    -- сразу возвращаем, зачем ещё что-то проверять, если это заведомо
    -- больше всех
    return 100000
  end

  local k = 1                  -- коэффициент привлекательности смарта
  local self_lname = object_level_name( self )
  if object_level_name( obj ) ~= self_lname then
    -- смарт на другой локации будет привлекательнее смарта на текущей
    -- локации непися. Полагаю, это приведет к большей движухе.
    k = 10 + math.random( 0, 10 )
  end

  local v = 0        -- посчитаем доступное на уровне количество работ
  -- перебираем все гулаги на одном уровне с этим
  for id, strn in pairs( smart_terrains[ self_lname ] ) do
    if strn:is_gulag_available() then -- если они доступны
      -- то суммируем их вакансии
      v = v + strn.gulag.capacity - strn.gulag:get_population()
    end
  end
  -- непонятен критерий! Получается, неэксклюзивный непись почти
  -- всегда пойдёт на уровень с тупо большим числом смартов, а уровни
  -- с небольшим количеством смартов заселятся в последнюю очередь.
  -- надо подумать над критерием.  Кроме того, непонятно, где
  -- прописывается ограничение по рангу/силе монстров. Может это
  -- сделать здесь?
  return v * k -- возвращаем фактически число вакансий на уровне
end


-- добавить npc в smart terrain.  если места нету или нету свободных
-- подходящих работ, то вытолкнуть из этого smart terrain с подходящей
-- работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )
  -- log2(
  --   "[smart_terrain %s] register called obj=%s gulag_type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )
  local npc_info = {
    -- старые squad и group
    o_group   = obj:g_group(),
    o_squad   = obj:g_squad(),
    exclusive = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive,
    stay_end  = game.get_game_time()
  }
  self:fill_npc_info( obj, npc_info )

  if
    self.gulag_working
    and not self.gulag:is_there_any_suitable_job( npc_info, false )
  then
    log2(
      "get_population = %d, capacity = %d",
      self.gulag:get_population(), self.gulag.capacity
    )
    log2(
      "is_there_any_suitable_job = %s",
      tostring( self.gulag:is_there_any_suitable_job( npc_info, false ) )
    )
    print_table( self.npc_info )
    self:kick_someone_non_exclusive( npc_info )
  end

  self:update_obj_rank( obj )
  obj.was_in_smart_terrain = true
  self.npc_info[ obj.id ] = npc_info

  if not self.gulag_working then
    self:create_gulag()
  end
  self.gulag:addObject( obj.id )
  self.gulag:update()

  if db.actor and self.gulag:dsh_is_full() then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_full_smart_terrain", self )
  end
  -- log2(
  --   "[smart_terrain %s] added %s to gulag type=%s",
  --   self:name(), obj:name(), self.gparams.type
  -- )
end


-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
  -- Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить
  -- счетчик эксклюзивности
  if obj.smart_terrain_conditions then
    local any_exclusive = false
    for name, condlist in pairs( obj.smart_terrain_conditions ) do
      local s = xr_logic.pick_section_from_condlist(
        db.actor_proxy, obj, condlist
      )
      if s ~= nil then
        if name == self:name() then
          -- уменьшаем счетчик
          self.exclusives = self.exclusives - 1
          self.gulag.capacity_non_exclusive =
            self.gulag.capacity_non_exclusive + 1
        end
      end
    end
  end

  local n = self.npc_info[ obj.id ]
  if not n then
    log1( debug.traceback() )
    log2( "self.npc_info[obj.id] = nil !!! obj.id=%d", obj.id )
    self:print()
    self.gulag:print()
  end

  self.gulag:removeObject( obj.id )
  obj.squad = n.o_squad
  obj.group = n.o_group
  self.npc_info[ obj.id ] = nil
  obj:clear_smart_terrain()
  dsh.remember_mobs_smart_terrain( obj.id, self, false )

  if self:is_empty() and db.actor then
    local sm = ogse_signals.get_mgr()
    sm:call( "on_empty_smart_terrain", self )
  end
  -- log2(
  --   "[smart_terrain %s] removed %s from gulag type=%s, strn_id=%s",
  --   self:name(), obj:name() or "<<<nil>>>", self.gparams.type, obj:smart_terrain_id()
  -- )
end


function se_smart_terrain:is_empty()
  for id, v in pairs( self.npc_info ) do
    return false
  end
  return true
end


-- изменть ранг сталкера при регистрации в смарт
function se_smart_terrain:update_obj_rank( obj )
  local community, is_stalker = self:get_obj_community( obj )
  if is_stalker then
    local old_rank = obj:rank()
    obj:set_rank(
      old_rank + math.random( self.rank_inc_min, self.rank_inc_max )
    )
    -- log2(
    --   "[smart_terrain %s] obj=%s rank %d -> %d",
    --   self:name(), obj:name(), old_rank, obj:rank()
    -- )
  end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного
-- персонажа, который занимает работу, подходящую новому персонажу.
--
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
  for obj_id, npc_info in pairs( self.npc_info ) do
    if
      ( not npc_info.exclusive )
      and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info )
    then
      log2( "[smart_terrain %s] kicking %s", self:name(), npc_info.name )
      self:unregister_npc( npc_info.se_obj )
      return
    end
  end
  abort(
    "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs",
    self:name()
  )
end

-- выдать объекту задание.
function se_smart_terrain:task( obj )
  if xr_companion.is_companion( obj.id ) then -- и как он здесь оказался?
    self:unregister_npc( obj )
    return CALifeSmartTerrainTask( "simulation_default_path" )
  end
  ASSERT(
    ( not dsh.is_free_logic_mob( obj ) ),
    "smart_terrain %s is trying to assign task to %s",
    self:name(), obj:name()
  )
  local path_name = self.gulag:get_obj_job_path_name( obj.id )
  if not path_name then
    -- log2(
    --   "[smart_terrain %s] task: obj=%s job_path=nil, CLEARING",
    --   self:name(), obj:name()
    -- )
    self:unregister_npc( obj )  --'Затычка против вылета.
    return CALifeSmartTerrainTask( "simulation_default_path" )
  end
  return CALifeSmartTerrainTask( path_name )
end


-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
  if self.gparams.cond then
    local bb = xr_logic.pick_section_from_condlist(
      db.actor_proxy, self, self.gparams.cond
    ) ~= nil
    return bb
  else
    return true
  end
end


-- установка/снятие блокировки приёма персонажей
function se_smart_terrain:lock_population( need_lock )
  self.population_locked = need_lock
end


-- в гулаг поступил первый персонаж и он начинает работать
function se_smart_terrain:create_gulag()
  self.duration_end = game.CTime()
  self.duration_end:setHMSms(
    math.random( self.gparams.duration_min, self.gparams.duration_max ), 0, 0, 0
  )
  self.duration_end:add( game.get_game_time() )
  self.check_time = CTime_0
  self.gulag:initialize()
  self.gulag_working = true
end


-- всех освободить, убить гулаг, создать новый нерабочий гулаг,
-- зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
  self.disabled = disable
  if not self.gulag_working then
    return
  end
  -- log2(
  --   "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type
  -- )
  -- освободить всех персонажей
  for id, npc_info in pairs( self.npc_info ) do
    self:unregister_npc( npc_info.se_obj )
  end
  if self.gparams.idle_max > 0 then
    self.idle_end = game.CTime()
    self.idle_end:setHMSms(
      math.random( self.gparams.idle_min, self.gparams.idle_max ), 0, 0, 0
    )
    self.idle_end:add( game.get_game_time() )
  else
    self.idle_end = nil
  end
  self.gulag = xr_gulag.gulag(
    self, self.gparams.type, self.gparams.squad, self.gparams.groups,
    self.npc_info, self.gparams.capacity
  )
  self.gulag:load_jobs()
  self.gulag_working = false
  self.gulag.capacity_non_exclusive =
    self.gulag.capacity_non_exclusive - self.exclusives
end


-- заполняет таблицу monster_classes
function se_smart_terrain:fill_monster_classes()
  if not monster_classes then
    monster_classes = {
      [clsid.bloodsucker_s ] = "bloodsucker",
      [clsid.boar_s        ] = "boar",
      [clsid.burer_s       ] = "burer",
      [clsid.cat_s         ] = "cat",
      [clsid.chimera_s     ] = "chimera",
      [clsid.controller_s  ] = "controller",
      [clsid.pseudodog_s   ] = "pseudodog",
      [clsid.psy_dog_s     ] = "psy_dog",
      [clsid.dog_s         ] = "dog",
      [clsid.flesh_s       ] = "flesh",
      [clsid.fracture_s    ] = "fracture",
      [clsid.poltergeist_s ] = "poltergeist",
      [clsid.gigant_s      ] = "pseudo_gigant",
      [clsid.snork_s       ] = "snork",
      [clsid.tushkano_s    ] = "tushkano",
      [clsid.zombie_s      ] = "zombie"
    }
  end
end


-- возвращает название уровня, на котором находится smart terrain
function se_smart_terrain:get_level_name()
  return object_level_name( self )
end

-- регистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_register()
  cse_alife_smart_zone.on_register( self )
  self:register_if_needed()
  self:initialize_if_needed()
end


function se_smart_terrain:register_if_needed()
  --' Если уже зарегистрены то ничего не делать.
  if self.registred == true then
    return
  end
  self.registred = true
  -- log2( "%s register called", self:name() )
  if self.disabled then
    return
  end
  self:fill_monster_classes()
  local level_name = self:get_level_name()
  if not self.gparams.preset_name then
    self.gparams.preset_name = level_name
  end
  if not smart_terrains[ level_name ] then
    smart_terrains[level_name] = {}
  end
  smart_terrains[ level_name ][ self.id ] = self
  smart_terrains_by_name[ self:name() ]   = self
  if self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = self
  end
  self.gulag:load_jobs()
  if self.gulag_working then
    self.gulag:initialize()
  end
  -- Регистрация в таскменеджере
  task_manager.get_random_task():register_target( self )
end


-- дерегистрация объекта в симуляторе.
-- вызывается симулятором.
function se_smart_terrain:on_unregister()
  cse_alife_smart_zone.on_unregister( self )
  -- log2( "[smart_terrain %s] on_unregister called", self:name() )
  local lvl_smarts = smart_terrains[ self:get_level_name() ]
  if lvl_smarts then
    lvl_smarts[ self.id ] = nil
  end
  smart_terrains_by_name[ self:name() ] = nil
  if self.gparams and self.gparams.respawn then
    db.strn_by_respawn[ self.gparams.respawn ] = nil
  end
  db.actor_proxy:deinit()
end


-- вызвать спавнер, если настроен.
function se_smart_terrain:call_respawn()
  if self.gparams.respawn then
    se_respawn.spawn( self.gparams.respawn )
  end
end


-- возвращает строку с принимаемыми группировками и рангами
function se_smart_terrain:stat_get_accepted_communities()
  local comms = {}
  -- from preset
  local iniFileName = "misc\\" .. self.gparams.type .. ".ltx"
  local preset_name = self.gparams.preset_name
  if iniLineSectionExist( preset_name, iniFileName ) then
    local n = iniLinesCount( preset_name, iniFileName )
    for i = 0, n - 1 do
      local result, field, str = getIniLine(
        preset_name, i, "", "", iniFileName
      )
      if
        ( not self.accepted_communities )
        or self.accepted_communities[field]
      then
        comms[ field ] = str
      end
    end
  end
  -- from custom data
  if self.accepted_communities then
    for comm, v in pairs( self.accepted_communities ) do
      if not comms[ comm ] then
        comms[ comm ] = "all"
      end
    end
  end
  -- prepare return
  local s = ""
  for comm, ranks in pairs( comms ) do
    s = s .. comm .. "(" .. ranks .. "),"
  end
  return s
end


-- вывод статистики смарта
function se_smart_terrain:stat()
  local s     = self:get_level_name() .. " " .. self:name()
  local pop   = self.gulag:get_population()
  local cap   = self.gulag.capacity
  local avail = self:is_gulag_available()
  if avail then
    s = s .. " enabled "
  else
    s = s .. " disabled "
  end
  s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()
  log1( s )
  for id, npc_info in pairs( self.npc_info ) do
    log2( "    %s", npc_info.name )
  end
  return avail, pop, cap
end


-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования
-- гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
  cse_alife_smart_zone.update( self )
  if not self.gulag_working then
    return
  end
  if self:is_gulag_available() then
    if self.check_time < game.get_game_time() then
      self.check_time = game.get_game_time() + check_period
      --' проверять, не собрался ли кто-то к этому времени уже уходить
      for id, npc_info in pairs( self.npc_info ) do
        if
          npc_info.cond
          and xr_logic.pick_section_from_condlist(
            db.actor_proxy, npc_info.se_obj, npc_info.cond
          ) == nil
        then
          -- log2( "[smart_terrain %s] leaving %s", self:name(), npc_info.name )
          self:unregister_npc( npc_info.se_obj )
        end
      end
      if self.gulag:get_population() == 0 then
        self:remove_gulag( self.id )
      else
        self.gulag:update()
      end
    end
  else
    self:remove_gulag()
  end
end


function se_smart_terrain:dsh_begin_job( id )
  local t = game.CTime()
  t:setHMSms(
    math.random( self.gparams.stay_min, self.gparams.stay_max ),
    math.random( 0, 59 ), 0, 0
  )
  t:add( game.get_game_time() )
  self.npc_info[ id ].stay_end = t
end


function se_smart_terrain:set_idle_timer( hours, not_exists )
  local tname  = "smart_terrain." .. self:name() .. ".population_locked"
  if ogse_st_mgr.timer_exists( tname ) then
    if not_exists then
      return false
    end
    local t = ogse_st_mgr.get_timer( tname )
    t:stop()
  end
  dsh.start_gtimerDHMS(
    tname, 0, hours, 0, 0, script_name() .. ".on_after_idle_timer"
  )
  return true
end
function on_after_idle_timer() end


function se_smart_terrain:try_set_idle_timer( last_sobj )
  if self.idle_time_monster or self.idle_time_stalker then
    ASSERT(
      ( IsStalker( last_sobj ) or IsMonster( last_sobj ) ),
      "unknown last_sobj: %s", last_sobj:name()
    )
    local t_min, t_max
    if IsStalker( last_sobj ) and last_sobj:community() ~= "zombied" then
      if self.idle_time_stalker then
        t_min, t_max = unpack( self.idle_time_stalker )
      end
    else
      if self.idle_time_monster then
        t_min, t_max = unpack( self.idle_time_monster )
      end
    end
    if t_min and t_max then
      local hours = ( t_min == t_max ) and t_max or math.random( t_min, t_max )
      if hours > 0 then
        -- блокировать смарт на hours часов, если он еще не заблокирован.
        self:set_idle_timer( hours, true )
      end
    end
  end
end


function on_death( id )
  -- log2( "on_death id=%d", id )
  if alife() then
    local sobj = alife():object( id )
    if sobj and sobj.smart_terrain_id then
      local strn_id       = sobj:smart_terrain_id()
      local free_logic_id = dsh.is_free_logic_mob( sobj )
      if free_logic_id then
        strn_id = free_logic_id
      end
      if strn_id ~= 65535 then
        -- обертка для фикса кривых smart_terrain
        local strn = alife():object( strn_id )
        if strn then
          if strn:clsid() == clsid.smart_terrain then
            strn.gulag:clear_dead( id )
            if strn:is_empty() then
              -- clear_dead() вызовет strn:unregister_npc(), а он
              -- вызовет событие on_empty_smart_terrain, обработчик
              -- которого тоже может заблокировать этот смарт на
              -- время. Поэтому, здесь смарт будет блокироваться
              -- только в том случае, если его еще никто другой не
              -- заблокировал.
              strn:try_set_idle_timer( sobj )
            end
          else
            log1(
              "load ~~~ smart_terrain.on_death: Обнаружена привязка к несуществующему smart_terrain: "..sobj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
            )
            sobj:clear_smart_terrain()
          end
        end
      end
    end
  end
end


--' Удаляет объект из смарттеррейнов.
function unregister_npc( npc )
  local sim = alife()
  if sim then
    local obj           = sim:object( npc.id )
    local strn_id       = obj:smart_terrain_id()
    local free_logic_id = dsh.is_free_logic_mob( npc )
    if free_logic_id then
      strn_id = free_logic_id
    end
    if strn_id ~= 65535 then
      -- обертка для фикса кривых smart_terrain
      local strn = sim:object( strn_id )
      if strn then
        if strn:clsid() == clsid.smart_terrain then
          strn:unregister_npc( obj )
        else
          log1(
            "smart_terrain.unregister_npc: Обнаружена привязка к несуществующему smart_terrain: "..obj:name()..", smart_terrain_id: "..tostring(strn_id)..". Привязка удалена."
          )
          obj:clear_smart_terrain()
        end
      end
    end
  end
end


-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
function read_smart_terrain_conditions( self )
  if self.ini and self.ini:section_exist( smart_section ) then
    local conds   = {}
    local accepts = false
    local n = self.ini:line_count( smart_section )
    if n > 0 then
      for i = 0, n - 1 do
        local result, field, str = self.ini:r_line( smart_section, i, "", "" )
        str = string.gsub( str, "{\-aes_arrive_to}", "true" )
        conds[ field ] = xr_logic.parse_condlist(
          self, smart_section, field, str
        )
      end
      return conds
    end
  end
end

-- Вывод статистики по всем смартам в симуляции
function stat()
  log1(
    "--------------- Smart terrains statistics START ----------------------"
  )
  local jobs, jobs_in_avail, occupied
  local level_stats = {}
  for level_name, t in pairs( smart_terrains ) do
    jobs, jobs_in_avail, occupied = 0, 0, 0
    for id, strn in pairs( t ) do
      local avail, pop, cap = strn:stat()
      jobs     = jobs     + cap
      occupied = occupied + pop
      if avail then
        jobs_in_avail = jobs_in_avail + cap
      end
    end
    local l = {}
    level_stats[ level_name ] = l
    l.jobs          = jobs
    l.occupied      = occupied
    l.jobs_in_avail = jobs_in_avail
  end
  jobs, jobs_in_avail, occupied = 0, 0, 0
  log1( "" )
  for level_name, l in pairs( level_stats ) do
    log2( "Level %s :", level_name )
    log2( "    Jobs in all smart terrains : %d",       l.jobs )
    log2( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
    log2( "    Occupied jobs : %d",                    l.occupied )
    jobs          = jobs          + l.jobs
    jobs_in_avail = jobs_in_avail + l.jobs_in_avail
    occupied      = occupied      + l.occupied
  end
  log1( "All levels:" )
  log2( "    Jobs in all smart terrains : %d",       jobs )
  log2( "    Jobs in available smart terrains : %d", jobs_in_avail )
  log2( "    Occupied jobs : %d",                    occupied )
  log1(
    "--------------- Smart terrains statistics END ------------------------"
  )
end


function get_smart_terrain_by_name( name )
  local obj = smart_terrains_by_name[ name ]
  if obj then
    return alife():object( obj.id )
  end
end


function iterate_smart_terrains( f )
  for name, _ in pairs( smart_terrains_by_name ) do
    local sobj = get_smart_terrain_by_name( name )
    if sobj then
      f( sobj )
    end
  end
end


function get_monster_classes()
  return monster_classes
end
