-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_empty_smart_terrain", fun = this.on_empty_smart })
  sm:subscribe({ signal = "on_full_smart_terrain",  fun = this.on_full_smart })
end


function periodic_job()
  log2( "[%s]: start periodic_job", script_name() )
  local gogogo = {}
  local cnt    = 0
  smart_terrain.iterate_smart_terrains( function( strn )
    if not is_walking_smart( strn ) then return end
    strn:initialize_if_needed()
    local gulag = strn.gulag
    if gulag then
      for _, sobj in ipairs( get_walk_npc( strn ) ) do
        table.insert( gogogo, sobj )
      end
      cnt = cnt + 1
    end
  end )
  local rnd_go = {}
  while table.getn( gogogo ) > 0 do
    table.insert(
      rnd_go,
      table.remove( gogogo, math.random( table.getn( gogogo ) ) )
    )
  end
  gogogo = rnd_go
  for _, sobj in ipairs( gogogo ) do
    sobj:brain():can_choose_alife_tasks( true )
    smart_terrain.unregister_npc( sobj )
  end
  for _, sobj in ipairs( gogogo ) do
    sobj:brain():update()
  end
  local next_m = math.random( 0, 59 )
  dsh.start_gtimerDHMS(
    script_name() .. ".periodic_job",
    0, 1, next_m, 0,
    script_name() .. ".periodic_job"
  )
  log2( "[%s]: stop periodic_job: %s smart_terrains, %s gogogo mobs, next run in 1 hour %s minutes", script_name(), cnt, table.getn( gogogo ), next_m )
end


function is_walking_smart( strn )
  local name     = strn:name()
  local res      = get_bool( "dsh.gulag.free_logic", name, false )
  local dsh_sect = "dsh.gulag.override." .. name
  local profile  = strn.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  if
    sys_ini:section_exist( sect )
    and sys_ini:line_exist( sect, "dsh_walking" )
  then
    local cond = get_string( sect, "dsh_walking" )
    if cond then
      local pc = xr_logic.parse_condlist( nil, sect, "dsh_walking", cond )
      res = xr_logic.pick_section_from_condlist( db.actor, db.actor, pc ) ~= nil
    end
  end
  return res
end


function get_walk_npc( strn )
  local name     = strn:name()
  local gulag    = strn.gulag
  local dsh_sect = "dsh.gulag.override." .. name
  local profile  = strn.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  local keep_min = 0
  if sys_ini:section_exist( sect ) then
    keep_min = get_u32( sect, "dsh_walking_keep_min", keep_min )
  end
  local comed    = gulag:get_population_comed()
  local gogogo   = {}
  if comed < keep_min + 1 then return gogogo end
--  log2( "[%s]: %s has enough comed %s, keep_min = %s", script_name(), name, comed, keep_min )
  local comed_npc = {}
  for id, v in pairs( strn.npc_info ) do
    local npc_sobj = alife():object( id )
    if
      npc_sobj and not v.exclusive
      and not gulag.Object_didnt_begin_job[ id ]
    then
      table.insert( comed_npc, {
        diff_sec = game.get_game_time():diffSec( v.stay_end ),
        sobj     = npc_sobj,
      })
--      log2( "[%s]: %s: %s is comed", script_name(), name, npc_sobj:name() )
    end
  end
  if table.getn( comed_npc ) > 0 then
    table.sort( comed_npc, function( a, b )
      return a.diff_sec > b.diff_sec
    end )
    local ready_to_go     = {}
    local not_ready_to_go = {}
    for _, v in ipairs( comed_npc ) do
      if v.diff_sec < 0 then
        table.insert( not_ready_to_go, v )
--        log2( "[%s]: %s: %s is not ready to go", script_name(), name, v.sobj:name() )
      elseif is_too_bad_weather( v.sobj ) then
        table.insert( not_ready_to_go, v )
--        log2( "[%s]: %s: %s is not ready to go, too bad weather", script_name(), name, v.sobj:name() )
      elseif is_too_late( v.sobj ) then
        table.insert( not_ready_to_go, v )
--        log2( "[%s]: %s: %s is not ready to go, too late", script_name(), name, v.sobj:name() )
      else
        table.insert( ready_to_go,     v )
--        log2( "[%s]: %s: %s is ready to go", script_name(), name, v.sobj:name() )
      end
    end
--    log2( "[%s]: %s: ready to go %s", script_name(), name, table.getn( ready_to_go ) )
    local allowed_to_go = comed - keep_min
--    log2( "[%s]: %s: allowed to go %s", script_name(), name, allowed_to_go )
    local walkable      = math.min(
      allowed_to_go, table.getn( ready_to_go )
    )
--    log2( "[%s]: %s: walkable %s", script_name(), name, walkable )
    local num_to_go     = math.random( 0, walkable )
--    log2( "[%s]: %s: num to go %s", script_name(), name, num_to_go )
    if
      keep_min == 0         -- могут уйти все
      and num_to_go > 0
      and num_to_go == table.getn( ready_to_go ) -- идут все, кто собрался
      and table.getn( not_ready_to_go ) == 1     -- остается один
      and math.random() < 0.5
    then
      -- да ну нафиг, я тоже тогда пойду с мужиками.
      num_to_go = num_to_go + 1
      table.insert( ready_to_go, table.remove( not_ready_to_go ) )
--      log2( "[%s]: %s: me too", script_name(), name )
    end
    while num_to_go > 0 do
      local npc_sobj = ready_to_go[ num_to_go ].sobj
--      log2( "[%s]: %s: go go go %s", script_name(), name, npc_sobj:name() )
      table.insert( gogogo, npc_sobj )
      num_to_go = num_to_go - 1
    end
  end
  return gogogo
end


function is_too_bad_weather( npc )
  local weather = ogse_weather_mgr.monitoring_weather_sect
  return ( string.find( weather, "storm" ) and math.random() < 0.9 )
end


function is_too_late( npc )
  local htime = level.get_time_hours()
  if IsStalker( npc ) and htime <= 4 or htime >= 21 then
    if math.random() < 0.7 then return true end
  end
  return false
end


function on_empty_smart( strn )
  local dsh_sect = "dsh.gulag.override." .. strn:name()
  local profile  = strn.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  local change_on_empty, restrictors
  if sys_ini:section_exist( sect ) then
    change_on_empty = get_string( sect, "dsh_change_profile_on_empty" )
    restrictors     = get_string( sect, "dsh_cleanup_restrictors" )
  end
  if not change_on_empty then return end
  local cond = xr_logic.parse_condlist(
    nil, sect, "dsh_change_profile_on_empty", change_on_empty
  )
  if xr_logic.pick_section_from_condlist( db.actor, db.actor, cond ) == nil then
    return
  end
  log2( "dsh: change_on_empty %s", strn:name() )
  local profiles
  if sys_ini:section_exist( sect ) then
    profiles = get_string( sect, "dsh_profiles" )
  end
  ASSERT( profiles, "profiles not found for %s", strn:name() )
  log2( "dsh: profiles for %s: %s", strn:name(), profiles )
  local new_profile = select_prob_name( parse_probs( profiles ) )
  log2( "dsh: new profile for %s: %s", strn:name(), new_profile )
  switch_smart_terrain_profile( strn, new_profile )
  if restrictors then
    log2( "dsh: cleanup restrictors: %s", restrictors )
    for _, k in ipairs( parse_names( restrictors ) ) do
      local sobj = alife():object( k )
      if sobj then
        alife():release( sobj )
        log2( "dsh: %s released", k )
      end
    end
  end
  local after_delay = get_string( sect, "dsh_after_delay" )
  if after_delay then
    local t1, t2 = unpack( parse_nums( after_delay ) )
    local delay  = math.random( t1, t2 )
    log2( "dsh: start delay timer: %s, %s", strn:name(), delay )
    local tname  = "smart_terrain." .. strn:name() .. ".population_locked"
    if ogse_st_mgr.timer_exists( tname ) then
      local t = ogse_st_mgr.get_timer( tname )
      t:stop()
    end
    dsh.start_gtimerDHMS(
      tname, 0, delay, 0, 0, script_name() .. ".on_after_delay_timer"
    )
  end
end


function on_after_delay_timer()
end


function parse_probs( str )
  local t = {}
  local last
  for _, k in ipairs( parse_names( str ) ) do
    if last then
      local p = tonumber( k )
      if p then
        last.prob = p
        last      = nil
      else
        last = {
          [ "name" ] = k,
          [ "prob" ] = 1,
        }
        table.insert( t, last )
      end
    else
      last = {
        [ "name" ] = k,
        [ "prob" ] = 1,
      }
      table.insert( t, last )
    end
  end
  return t
end


function select_prob_name( t )
  local sum = 0
  for _, v in ipairs( t ) do
    sum = sum + v.prob
  end
  ASSERT( sum > 0, "wrong sum = %s", sum )
  if sum > 1 then
    sum = math.random( 1, sum )
  end
  for _, v in ipairs( t ) do
    sum = sum - v.prob
    if sum <= 0 then
      return v.name
    end
  end
  ASSERT( nil, "nothing found: sum = %s", sum )
end


function switch_smart_terrain_profile( strn, profile )
  local pk = xs_netpk.smart_terrain( strn )
  ASSERT( pk:isOk(), "can't read netpk of %s", strn:name() )
  local data = pk:get()
  local cd   = data.custom_data:getTable()
  if not cd.dsh then cd.dsh = {} end
  cd.dsh.active_profile = profile
  data.custom_data:set( cd )
  pk:set( data )
  strn.dsh_active_profile = profile
  strn:dsh_override_params()
  if strn.communities then
    local comms = parse_names( strn.communities )
    strn.accepted_communities = {}
    for i, v in ipairs( comms ) do
      strn.accepted_communities[ v ] = true
    end
  end
  strn:remove_gulag( strn.id )
end


function on_full_smart( strn )
  local dsh_sect = "dsh.gulag.override." .. strn:name()
  local profile  = strn.dsh_active_profile
  local sect
  if profile then
    sect = dsh_sect .. "." .. profile
  else
    sect = dsh_sect
  end
  local population_locked
  if sys_ini:section_exist( sect ) then
    population_locked = get_string( sect, "dsh_population_locked" )
  end
  if population_locked then
    local cond = xr_logic.parse_condlist(
      nil, sect, "dsh_population_locked", population_locked
    )
    if
      xr_logic.pick_section_from_condlist( db.actor, db.actor, cond ) ~= nil
    then
      log2( "dsh: dsh_population_locked %s", strn:name() )
      strn:lock_population( true )
    end
  end
end
