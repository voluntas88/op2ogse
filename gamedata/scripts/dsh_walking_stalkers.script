-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_first_update_another_level", fun = this.on_spawn })
  sm:subscribe({ signal = "on_empty_smart_terrain", fun = this.on_empty_smart })
end


function on_spawn()
  local gogogo = {}
  smart_terrain.iterate_smart_terrains( function( strn )
    if not is_walking_smart( strn ) then return end
    strn:initialize_if_needed()
    local gulag = strn.gulag
    if gulag then
      for _, sobj in ipairs( get_walk_npc( strn ) ) do
        table.insert( gogogo, sobj )
      end
    end
  end )
  for _, sobj in ipairs( gogogo ) do
    sobj:brain():can_choose_alife_tasks( true )
    smart_terrain.unregister_npc( sobj )
  end
  for _, sobj in ipairs( gogogo ) do
    sobj:brain():update()
  end
end


function is_walking_smart( strn )
  local name     = strn:name()
  local res      = get_bool( "dsh.gulag.free_logic", name, false )
  local dsh_sect = "dsh.gulag.override." .. name
  local sects    = { dsh_sect }
  local profile  = strn.dsh_active_profile
  if profile then
    table.insert( sects, dsh_sect .. "." .. profile )
  end
  for _, curr_sect in ipairs( sects ) do
    if sys_ini:section_exist( curr_sect ) then
        res = get_bool( curr_sect, "dsh_walking", res )
    end
  end
  return res
end


function get_walk_npc( strn )
  local name     = strn:name()
  local gulag    = strn.gulag
  local dsh_sect = "dsh.gulag.override." .. name
  local sects    = { dsh_sect }
  local profile  = strn.dsh_active_profile
  if profile then
    table.insert( sects, dsh_sect .. "." .. profile )
  end
  local keep_min = 0
  for _, curr_sect in ipairs( sects ) do
    if sys_ini:section_exist( curr_sect ) then
      keep_min = get_u32( curr_sect, "dsh_walking_keep_min", keep_min )
    end
  end
  local comed    = gulag:get_population_comed()
  local gogogo   = {}
  if comed < keep_min + 1 then return gogogo end
  log2( "[%s]: %s has enough comed %s, keep_min = %s", script_name(), name, comed, keep_min )
  local comed_npc = {}
  for id, v in pairs( strn.npc_info ) do
    local npc_sobj = alife():object( id )
    if
      npc_sobj and not v.exclusive
      and not gulag.Object_didnt_begin_job[ id ]
    then
      table.insert( comed_npc, {
        diff_sec = game.get_game_time():diffSec( v.stay_end ),
        sobj     = npc_sobj,
      })
      log2( "[%s]: %s: %s is comed", script_name(), name, npc_sobj:name() )
    end
  end
  if table.getn( comed_npc ) > 0 then
    table.sort( comed_npc, function( a, b )
      return a.diff_sec > b.diff_sec
    end )
    local ready_to_go     = {}
    local not_ready_to_go = {}
    for _, v in ipairs( comed_npc ) do
      if v.diff_sec < 0 then
        table.insert( not_ready_to_go, v )
        log2( "[%s]: %s: %s is not ready to go", script_name(), name, v.sobj:name() )
      elseif is_too_bad_weather( v.sobj ) then
        table.insert( not_ready_to_go, v )
        log2( "[%s]: %s: %s is not ready to go, too bad weather", script_name(), name, v.sobj:name() )
      elseif is_too_late( v.sobj ) then
        table.insert( not_ready_to_go, v )
        log2( "[%s]: %s: %s is not ready to go, too late", script_name(), name, v.sobj:name() )
      else
        table.insert( ready_to_go,     v )
        log2( "[%s]: %s: %s is ready to go", script_name(), name, v.sobj:name() )
      end
    end
    log2( "[%s]: %s: ready to go %s", script_name(), name, table.getn( ready_to_go ) )
    local allowed_to_go = comed - keep_min
    log2( "[%s]: %s: allowed to go %s", script_name(), name, allowed_to_go )
    local walkable      = math.min(
      allowed_to_go, table.getn( ready_to_go )
    )
    log2( "[%s]: %s: walkable %s", script_name(), name, walkable )
    local num_to_go     = math.random( 0, walkable )
    log2( "[%s]: %s: num to go %s", script_name(), name, num_to_go )
    if
      keep_min == 0         -- могут уйти все
      and num_to_go > 0
      and num_to_go == table.getn( ready_to_go ) -- идут все, кто собрался
      and table.getn( not_ready_to_go ) == 1     -- остается один
      and math.random() < 0.5
    then
      -- да ну нафиг, я тоже тогда пойду с мужиками.
      num_to_go = num_to_go + 1
      table.insert( ready_to_go, table.remove( not_ready_to_go ) )
      log2( "[%s]: %s: me too", script_name(), name )
    end
    while num_to_go > 0 do
      local npc_sobj = ready_to_go[ num_to_go ].sobj
      log2( "[%s]: %s: go go go %s", script_name(), name, npc_sobj:name() )
      table.insert( gogogo, npc_sobj )
      num_to_go = num_to_go - 1
    end
  end
  return gogogo
end


function is_too_bad_weather( npc )
  local weather = ogse_weather_mgr.monitoring_weather_sect
  return ( string.find( weather, "storm" ) and math.random() < 0.9 )
end


function is_too_late( npc )
  local htime = level.get_time_hours()
  if IsStalker( npc ) and htime <= 4 or htime >= 21 then
    if math.random() < 0.7 then return true end
  end
  return false
end


function on_empty_smart( strn )
  local dsh_sect = "dsh.gulag.override." .. strn:name()
  local sects    = { dsh_sect }
  local profile  = strn.dsh_active_profile
  if profile then
    table.insert( sects, dsh_sect .. "." .. profile )
  end
  local change_on_empty = false
  for _, curr_sect in ipairs( sects ) do
    if sys_ini:section_exist( curr_sect ) then
      change_on_empty = get_bool(
        curr_sect, "dsh_change_profile_on_empty", change_on_empty
      )
    end
  end
  if not change_on_empty then return end
end
