-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm ) -- для менеджера сигналов
  sm:subscribe({ signal = "on_destroy", fun = this.on_destroy })
  sm:subscribe({ signal = "on_spawn",   fun = this.on_spawn  })
  sm:subscribe({ signal = "on_update",  fun = this.on_update })
end


-- читаем глобальные параметры эффектов здоровья
local satiety_v = get_float("actor_script_condition", "satiety_v")
ASSERT(satiety_v, "ogse_actor_conditions_mgr: 'satiety_v' parameter not found!")
local light_hunger_limit = get_float("actor_script_condition", "light_hunger_limit")
ASSERT(light_hunger_limit, "ogse_actor_conditions_mgr: 'light_hunger_limit' parameter not found!")
local critical_hunger_limit = get_float("actor_script_condition", "critical_hunger_limit")
ASSERT(critical_hunger_limit, "ogse_actor_conditions_mgr: 'critical_hunger_limit' parameter not found!")
local satiety_power_factor = get_float("actor_script_condition", "satiety_power_factor")
ASSERT(satiety_power_factor, "ogse_actor_conditions_mgr: 'satiety_power_factor' parameter not found!")
local satiety_health_v_base = get_float("actor_script_condition", "satiety_health_v")
ASSERT(satiety_health_v_base, "ogse_actor_conditions_mgr: 'satiety_health_v' parameter not found!")
local satiety_health_factor = get_float("actor_script_condition", "satiety_health_factor")
ASSERT(satiety_health_factor, "ogse_actor_conditions_mgr: 'satiety_health_factor' parameter not found!")
local max_stand_power = get_float("actor_condition", "stand_power")
ASSERT(max_stand_power, "ogse_actor_conditions_mgr: 'stand_power' parameter not found!")
local satiety_k = max_stand_power * (1 - satiety_power_factor) / light_hunger_limit

local engine_satiety_v = get_float("actor_condition", "satiety_v")
ASSERT(engine_satiety_v, "ogse_actor_conditions_mgr: 'actor_condition:engine_satiety_v' parameter not found!")
local engine_satiety_health_v = get_float("actor_condition", "satiety_health_v")
ASSERT(engine_satiety_health_v, "ogse_actor_conditions_mgr: 'actor_condition:satiety_health_v' parameter not found!")
local engine_satiety_power_v = get_float("actor_condition", "satiety_power_v")
ASSERT(engine_satiety_power_v, "ogse_actor_conditions_mgr: 'actor_condition:satiety_power_v' parameter not found!")

local sprint_koef = get_float( "actor", "sprint_koef" )
ASSERT(
  sprint_koef,
  "ogse_actor_conditions_mgr: 'actor:sprint_koef' parameter not found!"
)
local override_sprint_koef

local walk_accel = get_float( "actor", "walk_accel" )
ASSERT(
  walk_accel,
  "ogse_actor_conditions_mgr: 'actor:walk_accel' parameter not found!"
)
local min_walk_accel = 3

local jump_power = get_float( "actor_condition", "jump_power" )
ASSERT(
  jump_power,
  "ogse_actor_conditions_mgr: 'actor_condition:jump_power' parameter not found!"
)
local override_jump_power

local walk_power = get_float( "actor_condition", "walk_power" )
ASSERT(
  walk_power,
  "ogse_actor_conditions_mgr: 'actor_condition:walk_power' parameter not found!"
)


local pt
local cam_inert, cur_cam_inert

function on_spawn()
  pt = { game.get_game_time():get() }
  cam_inert     = get_con_float( "cam_inert" )
  cur_cam_inert = cam_inert
end


function on_destroy()
  if cam_inert then
    cmd( "cam_inert", cam_inert )
  end
end


local cached_item_cond_effects = {}
local function get_item_cond_effect(item)
	--TODO: сделать получение эффекта непосредственно из объекта
	if item == nil or alife():object(item:id()) == nil then return end
	local section = item:section()
	local ef = cached_item_cond_effects[section]
	if not ef then
		ef = {}
		ef.satiety_restore_speed  = get_float(section, "satiety_restore_speed", 0)
		ef.health_restore_speed   = get_float(section, "health_restore_speed", 0)
		ef.bleeding_restore_speed = get_float(section, "bleeding_restore_speed", 0)
		ef.power_restore_speed    = get_float(section, "power_restore_speed", 0)
		cached_item_cond_effects[section] = ef
	end
	return ef
end


local override_power = 1

function on_update()
	if not (db.actor and db.actor:alive()) then return end
	local act = db.actor
        if act.power > override_power then
          act.power = override_power - act.power
        end
	--log3("%04d/%02d/%02d %02d:%02d:%02d.%03d", unpack(pt))
	local previous_check_time = game.CTime()
	previous_check_time:set(unpack(pt))
	local current_time = game.get_game_time()
	local dt = current_time:diffSec(previous_check_time)
	if dt == 0 then return end
	pt = {current_time:get()}
	-- учитываем здесь естественное оголодание, а также движковое(обнулять его нельзя, на нем основан показ свойств артефактов)
	local cur_satiety_v = satiety_v + ( satiety_v * ( 1 - act.power ) )
        local satiety_custom_k = 1
        if override_power < 1 then
	  satiety_custom_k = 3
	elseif
	  act:is_actor_sprinting() or act:is_actor_climbing()
	  or
	  act.power < 0.9 or act:get_bleeding() > 0.1
	then
	  satiety_custom_k = 2
	end
	cur_satiety_v = cur_satiety_v * satiety_custom_k
	local summary_satiety_effect = cur_satiety_v + engine_satiety_v
	local summary_health_effect = satiety_health_v_base - engine_satiety_health_v
	local summary_power_effect = - engine_satiety_power_v
	local summary_bleeding_restore_effect = 0
	-- неучтённые в движке эффекты от артефактов на поясе
	for i=0,act:belt_count()-1 do
		local item = act:item_on_belt(i)
		local ef = get_item_cond_effect(item)
		if ef then
			local satiety_restore_speed = ef.satiety_restore_speed
			if act:is_actor_sprinting() or act:is_actor_climbing() then
			  if     satiety_restore_speed > 0 then
			    satiety_restore_speed = satiety_restore_speed / 2
			  elseif satiety_restore_speed < 0 then
			    satiety_restore_speed = satiety_restore_speed * 2
			  end
			end
			summary_satiety_effect = summary_satiety_effect + satiety_restore_speed
		end
	end
	-- эффекты от брони
	local armor = db.actor:item_in_slot(6)
	if armor then
		local ef = get_item_cond_effect(armor)
		if ef then
			local satiety_restore_speed = ef.satiety_restore_speed
			if act:is_actor_sprinting() or act:is_actor_climbing() then
			  if     satiety_restore_speed > 0 then
			    satiety_restore_speed = satiety_restore_speed / 2
			  elseif satiety_restore_speed < 0 then
			    satiety_restore_speed = satiety_restore_speed * 2
			  end
			end
			summary_satiety_effect = summary_satiety_effect + satiety_restore_speed
			summary_health_effect = summary_health_effect + ef.health_restore_speed
			summary_power_effect = summary_power_effect + ef.power_restore_speed
			summary_bleeding_restore_effect = summary_bleeding_restore_effect + ef.bleeding_restore_speed
		end
	end
	-- эффекты, связанные c голодом
	if act.satiety < light_hunger_limit then
		local sadd = (light_hunger_limit - act.satiety) * satiety_k
		summary_power_effect = summary_power_effect + sadd
	end

	if act.satiety < critical_hunger_limit then
		local hadd = (act.satiety - critical_hunger_limit) * satiety_health_factor
		summary_health_effect = summary_health_effect + hadd
	end
	
	-- TODO: учесть потерю сил и здоровья от недосыпа
	--
	--TODO: оптимизировать вычисление суммарного эффекта, 
	-- сделать это только по факту изменения объектов на поясе
	act.satiety = summary_satiety_effect * dt
	-- ограничиваем снизу. TODO: может учесть это в самом движке
	if act.satiety < 0 then act:set_actor_condition_float(nil, 0.0, 256) end
	act.health = summary_health_effect * dt
	act.power = summary_power_effect * dt
	if act:get_bleeding() > 0.1 and summary_bleeding_restore_effect > 0.0 then
		act:heal_wounds(summary_bleeding_restore_effect * dt)
	end
	--if act.satiety < 0.1 then act.satiety = 1 end

        local cur_sprint_koef = override_sprint_koef or sprint_koef
        set_sprint_factor( cur_sprint_koef )

        local cur_walk_accel = walk_accel - min_walk_accel
        if act.satiety < light_hunger_limit then
          cur_walk_accel = cur_walk_accel
            * ( act.satiety / light_hunger_limit )
        end
        if act.health < 0.7 then
          cur_walk_accel = cur_walk_accel * ( act.health / 0.7 )
        end
        local inv_weight  = db.actor:get_inventory_weight()
        local max_weight  = db.actor:get_actor_max_weight()
        local walk_weight = db.actor:get_actor_max_walk_weight()
        if armor then
          max_weight  = max_weight  + get_float(
            armor:section(), "additional_inventory_weight",  0
          )
          walk_weight = walk_weight + get_float(
            armor:section(), "additional_inventory_weight2", 0
          )
        end
        local new_cam_inert
        if inv_weight > max_weight then
          local k1     = ( inv_weight - max_weight ) / ( walk_weight - max_weight )
          local k2     = 1 - k1
          cur_walk_accel = cur_walk_accel * k2
          if k2 < 0.1 then
            override_power = 0.1
          else
            override_power = k2
          end
          local min_cam_inert = math.max( 0.4, cam_inert + 0.1 )
          if min_cam_inert < 0.8 then
            new_cam_inert = min_cam_inert + (
              math.round( ( 0.8 - min_cam_inert ) * k1 * 100 ) / 100
            )
          end
        else
          override_power = 1
          new_cam_inert  = cam_inert
        end
        set_walk_accel( min_walk_accel + cur_walk_accel )
        if new_cam_inert and new_cam_inert ~= cur_cam_inert then
          cmd( "cam_inert", new_cam_inert )
          cur_cam_inert = new_cam_inert
        end

        local cur_jump_power = override_jump_power or jump_power
        if act.satiety < light_hunger_limit then
          cur_jump_power = cur_jump_power + (
            ( 0.9 - cur_jump_power ) * ( 1 - ( act.satiety / light_hunger_limit ) )
          )
        end
        if act.health < 0.7 then
          cur_jump_power = cur_jump_power + (
            ( 0.9 - cur_jump_power ) * ( 1 - ( act.health / 0.7 ) )
          )
        end
        set_jump_power( cur_jump_power )

        local cur_walk_power = walk_power
        if act.satiety < light_hunger_limit then
          cur_walk_power = cur_walk_power + (
            ( 0.002 - cur_walk_power ) * ( 1 - ( act.satiety / light_hunger_limit ) )
          )
        end
        if act.health < 0.7 then
          cur_walk_power = cur_walk_power + (
            ( 0.002 - cur_walk_power ) * ( 1 - ( act.health / 0.7 ) )
          )
        end
        set_walk_power( cur_walk_power )
end


function disable_sprint()
  set_sprint( 1 )
end
function set_sprint( koef )
  override_sprint_koef = koef
end
function restore_sprint()
  set_sprint( nil )
end


function change_jump_power( k )
  override_jump_power = k
end
