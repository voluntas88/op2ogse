-- -*- mode: lua; coding: windows-1251-dos -*-
--//----------------------------------------
--//Автор: Singapur22 переписано Proper70
--//Дата выхода: 10.01.2010
--//-----------------------------------------

-- В эту таблицу вписывать только секции, которые не начинаются с af_
local list_arts = {
  [ "gold_art"            ] = true,
  [ "artifact_electro_crystal_thorn"] = true,
  [ "art_acumm"           ] = true,
  [ "5.45x39_izomorf"     ] = true,
  [ "5.45x39_izomorf_1"   ] = true,
  [ "osnova_fotik"        ] = true,
  [ "linza_fotik"         ] = true,
  [ "pushka_fotik"        ] = true,
  [ "rukzak_izomorf"      ] = true,
  [ "izom_globus"         ] = true,
  [ "izomorf_kristal"     ] = true,
  [ "ammo_zhekan_izomorf" ] = true,
  [ "kaktus_izomorf"      ] = true,
  [ "izomorf_kompas"      ] = true,
  [ "wa2000_izomorf"      ] = true,
  [ "7.62x54_izomorf"     ] = true,
  [ "psevdokristall"      ] = true,
  [ "izomorf_plastilin"   ] = true,
}

local snd_obj = xr_sound.get_safe_sound_object( "ambient\\da_beep" )


function attach( sm )
  sm:subscribe({ signal = "on_drop",         fun = this.remove_art_det })
  sm:subscribe({ signal = "on_first_update", fun = this.start_update   })
  sm:subscribe({ signal = "on_item_to_ruck", fun = this.remove_art_det })
  sm:subscribe({ signal = "on_item_to_slot", fun = this.use_art_det    })
end


function use_art_det( obj )
  local in_slot = db.actor:item_in_slot( 8 )
  if in_slot and in_slot:id() == obj:id() then
    subscribe()
    iteration_del_spot()
  end
end


function remove_art_det( obj )
  if not db.actor:item_in_slot( 8 ) then
    unsubscribe()
    iteration_del_spot()
  end
end


local signals
function subscribe()
  if not signals then
    signals = {
      { signal = "on_update", fun = this.on_update },
    }
    local sm = ogse_signals.get_mgr()
    for _, s in ipairs( signals ) do
      sm:subscribe( s )
    end
  end
end

function unsubscribe()
  if signals then
    local sm = ogse_signals.get_mgr()
    for _, s in ipairs( signals ) do
      sm:unsubscribe( s )
    end
    signals = nil
  end
end


function start_update()
  db.artefacts = {}
  local lname  = level.name()
  for id = 1, 65534 do
    local sobj = alife():object( id )
    -- Собираем в таблицу арты только на текущей территории
    if sobj and level.object_by_id( sobj.id ) then
      local section = sobj:section_name()
      if string.find( section, "^af_" ) or list_arts[ section ] then
        db.artefacts[ id ] = { spot = false, tim_beep = 0 }
      end
    end
  end
end


local update_t
function on_update()
  if update_t and update_t > time_global() then return end
  update()
  update_t = time_global() + snd_obj:length()
end


function update()
  local found = db.actor:item_in_slot( 8 )
  if found then
    found = found:section()
    if
      found == "det_artefact_super"
      and has_alife_info( "tel_dcity_kanaliy" )
    then
      det_super()
    elseif found == "detektor_amorf" then
      det_izomorf()
    elseif found == "det_artefact_indy" then
      det_indy()
    end
  end
end


function det_indy()
  local max_dist = 40 * 40
  for k, v in pairs( db.artefacts ) do
    local obj = level.object_by_id( k)
    if obj then
      if not obj:parent() then
        local dist = db.actor:position():distance_to_sqr( obj:position() )
        if dist <= max_dist then
          if v.tim_beep <= time_global() and not snd_obj:playing() then
            snd_obj:play_no_feedback(
              db.actor, sound_object.s2d, 0, vector(), 1.0
            )
            db.artefacts[ k ].tim_beep = time_global()
              + math.floor( dist / max_dist * 2500 )
          end
        else
          this.del_spot( k, v )
        end
      else
        this.del_spot( k, v )
      end
    end
  end
end


function det_izomorf()
  local time_g = time_global()
  for k, v in pairs( db.artefacts ) do
    local obj = level.object_by_id( k )
    if obj then
      if not obj:parent() then
        local dist = db.actor:position():distance_to_sqr( obj:position() )
        if dist < 60 * 60 then
          if not v.spot then
            level.map_add_object_spot(
              k, "artefact_location", game.translate_string(
                get_string( obj:section(), "inv_name" )
              )
            )
            db.artefacts[ k ].spot = true
          end
          if v.tim_beep < time_g and not snd_obj:playing() then
            db.artefacts[ k ].tim_beep = time_g + 2500
            snd_obj:play_no_feedback(
              db.actor, sound_object.s2d, 0, vector(), 1.0
            )
          end
        else
          this.del_spot( k, v )
        end
      else
        this.del_spot( k, v )
      end
    end
  end
end


function det_super()
  local time_g = time_global()
  for k, v in pairs( db.artefacts ) do
    local sobj = alife():object( k )
    if sobj then
      if sobj.parent_id == 65535 then
        if not v.spot then
          level.map_add_object_spot(
            k, "artefact_location", game.translate_string(
              get_string( sobj:section_name(), "inv_name" )
            )
          )
          db.artefacts[ k ].spot = true
        end
        local dist = db.actor:position():distance_to_sqr( sobj.position )
        if dist < 60 * 60 then
          if v.tim_beep < time_g and not snd_obj:playing() then
            db.artefacts[ k ].tim_beep = time_g + 2500
            snd_obj:play_no_feedback(
              db.actor, sound_object.s2d, 0, vector(), 1.0
            )
          end
        end
      else
        this.del_spot( k, v )
      end
    end
  end
end


function iteration_del_spot()
  for k, v in pairs( db.artefacts ) do
    if v.spot then
      local sobj = alife():object( k )
      if sobj then
        this.del_spot( k, v )
      end
    end
  end
end


function del_spot( k, v )
  if v.spot then
    level.map_remove_object_spot( k, "artefact_location" )
    db.artefacts[ k ].spot = false
  end
end


function not_falling( obj )
  local sobj = alife():object( obj:id() )
  if not sobj then
    -- серверный объект исчез - убираем из таблицы
    return false, nil
  end
  if sobj.position:distance_to( obj:position() ) - sobj.position:distance_to_xz( obj:position() ) > 10 then
    -- большая разница по высоте, скорее всего провалился, переспавниваем
    sobj = amk_anoms.respawn_falling_art( sobj )
    return false, sobj.id
  end
  return true, nil
end


function not_falling_se( sobj )
  local obj = level.object_by_id( sobj.id )
  if obj then
    return not_falling( obj )
  end
  return true, nil
end
