-- -*- mode: lua; coding: windows-1251-dos -*-
function attach( sm )
  sm:subscribe({ signal = "on_drop", fun = this.on_drop })
--  sm:subscribe({ signal = "on_take", fun = this.on_take })
  sm:subscribe({ signal = "on_use",  fun = this.on_use })
end


local inv_mines = {
  bomba_mina_b_inv = "bomba_mina_b",
  bomba_mina_n_inv = "bomba_mina_n",
}


function on_take( obj, sobj )
  if not sobj then return end
  local sect = obj:section()
  if babah.mines.sect[ sect ] then
      ogse.remove_item_from_inventory( obj )
      ogse.spawn_item_in_inv( sect .. "_inv" )
    return true
  end
end


function on_use( obj, sobj )
  if not sobj then return end
  local id   = obj:id()
  local sect = obj:section()
  if sect == "detonator" or sect == "detonator_2" then
    babah.useDetonator( sect )
    return true
  elseif babah.timeBombs.sect[ sect ] then
    babah.useTimeBomb({ id = id, sect = sect })
    return true
  end
end


local mines_on_timer = {}

function on_drop( obj, sobj )
  if not sobj then return end
  local id   = obj:id()
  local sect = obj:section()
  local real = inv_mines[ sect ] or (
    babah.mines.sect[ sect ] and sect
  )
  if real and sobj.parent_id == 65535 then
    ogse.remove_item( obj )
    local pos = calc_new_mine_pos()
    local new = alife():create( real, pos, db.actor:level_vertex_id(), db.actor:game_vertex_id() )
    level.client_spawn_manager():add(
      new.id, -1, function( id, obj )
        mines_on_timer[ new.id ] = dsh.timeout(
          babah.mines.sect[ real ].delay * 1000,
          function()
            local binder = obj:binded_object()
            binder.ready_to_explode = true
            mines_on_timer[ new.id ] = nil
          end
        )
      end
    )
    if level.main_input_receiver() then
      level.start_stop_menu( level.main_input_receiver(), true )
    end
    return true
  elseif string.find( sect, "^bomba_timer_" ) then
    if sobj.parent_id == 65535 then
      babah.dropTimeBomb({ id = id, sect = sect })
    else
      babah.relocateTimeBomb({ id = id, sect = sect })
    end
    return true
  end
end


function remove_mine( obj )
  local mine = babah.mines.sect[ obj:section() ]
  if not mine then return end
  local found = false
  for k, onLevel in pairs( mine.onLevels ) do
    for i, id in ipairs( onLevel ) do
      if obj.id == id then
        table.remove( onLevel, i )
        found = true
        break
      end
    end
    if found then break end
  end
  for i, id in ipairs( mine.ids ) do
    if obj.id == id then
      table.remove( mine.ids, i )
      found = true
      break
     end
  end
  for i, id in ipairs( mine.inInventory ) do
    if obj.id == id then
      table.remove( mine.inInventory, i )
      found = true
      break
    end
  end
  if found then
    babah.mines.count = babah.mines.count - 1
    ASSERT(
      not babah.mines.count < 0,
      "babah.mines.count is negative, %d", babah.mines.count
    )
  end
end


function calc_new_mine_pos()
  local pos = vector():mad( db.actor:position(), db.actor:direction(), 0.5 )
  return pos
end


function bind_mine( obj )
  local new_binder = generic_mine_binder( obj )
  obj:bind_object( new_binder )
end


class "generic_mine_binder" ( object_binder )
function generic_mine_binder:__init( obj ) super( obj )
  self.freq = 1000
  self.ready_to_explode = false
end


function generic_mine_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  self.dsh_update_t = 0
  return true
end


function generic_mine_binder:update( delta )
  object_binder.update( self, delta )
  if self.object:parent() then
    local id = self.object:id()
    if mines_on_timer[ id ] then
      mines_on_timer[ id ]:stop()
      mines_on_timer[ id ] = nil
    end
    self.ready_to_explode = false
    return
  end
  if self.dsh_update_t <= time_global() then
    if self.ready_to_explode then
      local pos = self.object:position()
      local exploded = false
      for _, k in ipairs({ "btr", "creature" }) do
        for id, _ in pairs( db[ k ] ) do
          local obj = level.object_by_id( id )
          if obj and obj:alive() and obj:position():distance_to( pos ) < 1.5 then
            self.object:explode()
            exploded = true
            break
          end
        end
        if exploded then break end
      end
    end
    self.dsh_update_t = time_global() + self.freq
  end
end


function generic_mine_binder:load( reader )
  object_binder.load( self, reader )
  self.ready_to_explode = true
end
