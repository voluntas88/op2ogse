-- -*- mode: lua; coding: windows-1251-dos -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

off_npcs={}
items={}
relation_matrix={}
tables_ready = false
sell_table = {}
local item_dependence = {}
always_keep_item = {}

local wpn_fp = {}
-- Пора апдейт делать
local bFlag       = false
-- Номер последнего отработанного обьекта
local iCounter    = 0
-- Время последнего глобального апдейта
local iTime       = -1
-- Как часто делать апдейты, игровые минуты
local iFreq       = 60
local initialized = false

local monster_params = {}

local maps={
  "l01_escape",
  "l02_garbage",
  "l03_agroprom",
--      "l03u_agr_underground",
  "l04_darkvalley",
--      "l04u_labx18",
  "l05_bar",
  "l06_rostok",
  "l07_military",
  "l08_yantar"--,
  --"l08u_brainlab",
  --"l10_radar",
  --"l10u_bunker",
  --"l11_pripyat",
  --"l12_stancia",
  --"l12_stancia_2",
  --"l12u_control_monolith",
  --"l12u_sarcofag"
}

protected = {
  names = {},             -- имена объектов (стоит добавлять только уникальные имена!)
  ids = {},               -- ID объектов
  story_ids = {   -- story ID объектов
    5008,
    5013,
    5014,
    5041,
    5065,
    5084,
    5104,
    5205,
    5222,
    5226,
    5237,
    5238,
    5243,
    5244,
    5245,
    5246,
    5247,
    5248,
    5249,
    5250,
    5254,
    5255,
    5408,
    5413,
    5428,
    5433,
    5434,
    5444,
    5446,
    5470,
    5471,
    5472,
    5473,
    5474,
    573
  },
  sections = {    -- секции объектов
    "volna_shron",
    "taynik_kuznec7",
    "dyak_mines_box",
    "radiodetail_box2",
    "radiodetail_box4",
    "keis_key_box",
    "computer_flash",
    "notebook_flash",
    "disk_flash",
    "pda_flash",
    "taynik_podarok"
  }
}

local smart_filters = {
  "esc_bridge", "esc_blokpost"
}


local rel_enemy,rel_friend

--радиус "обзора"
local look_radius=50
--интенсивность поиска (количество отрабатываемых неписей)
--local search_intensivity=40
local search_intensivity=60
-- продолжительность боев
local max_rounds = 10
-- При каком уровне здоровья НПС считается раненым
local health_wound = 0.20
local health_wound_set = 0.02
-- Эталон firepower\distance при distance = 1 который снимет 100% health
local base_fp = 1400
-- Коэффициент для расстояния
local dist_coeff = 8
-- Вещи дешевле продает торговцам
local sell_limit = 3000
-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_kill_base = 100
local rate_art_found = 100
local to_actor = 150
local look_radius_box = 10

local stalkers_comm = {
  [ "actor" ]           = true,
  [ "actor_dolg" ]      = true,
  [ "actor_freedom" ]   = true,
  [ "stalker" ]         = true,
  [ "dolg" ]            = true,
  [ "freedom" ]         = true,
  [ "bandit" ]          = true,
  [ "ecolog" ]          = true,
  [ "csky" ]            = true,
}


function init()
  if initialized == false then
    build_tables()
    iTime       = amk.game_minutes() - iFreq + 3
    initialized = true
  end
end


function update()
  if bFlag == false and iTime ~= -1 then
    if amk.game_minutes() - iTime > iFreq then
      bFlag    = true
      off_npcs = {}
      items    = {}
      iCounter = 1
    end
  end
  if bFlag == true then
    if iCounter >= 65535 then
      bFlag    = false
      iTime    = amk.game_minutes()
      iCounter = 1
    else
      local obj = alife():object( iCounter )
      add_fresh_meat( obj )
      iCounter = iCounter + 1
    end
  end
end


--on_death - не убиваем!
--on_hit - не обрабатываем!
function add_fresh_meat( obj )
  if
    obj and obj.m_game_vertex_id
    and game_graph():valid_vertex_id( obj.m_game_vertex_id )
    and db.actor and db.actor:id() ~= obj.id
    and not protected_items.actor_items_keep( obj:section_name() )
    and not protected_items.is_no_offline_alife_npc( obj:section_name() )
    and not get_bool( obj:section_name(), "quest_item", false )
    and not get_bool( obj:section_name(), "watcher_act.bad_item", false )
  then
    local map = alife():level_name(
      game_graph():vertex( obj.m_game_vertex_id ):level_id()
    )
    if not off_npcs[ map ] then
      off_npcs[ map ] = {
        artefacts = {},
        inv_boxes = {},
        monsters  = {},
        stalkers  = {},
        weapons   = {},
      }
    end
    if
      IAmAMonster[ obj:clsid() ] and obj.alive and obj:alive()
      and
      obj.health and obj:health()>0 and obj.m_story_id == 4294967296
    then
      local flags = get_flags( obj.id )
      if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
        table.insert(
          off_npcs[ map ].monsters, { id = obj.id, name = obj:name() }
        )
      end
    elseif
      IAmAStalker[ obj:clsid() ] and obj.alive and obj:alive()
      and
      obj.health and obj:health()>0 and obj.m_story_id == 4294967296
      and
      not xr_companion.is_companion(obj.id)
    then
      local flags = get_flags( obj.id )
      if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
        if obj:community() ~= "zombied" then
          table.insert(
            off_npcs[ map ].stalkers, { id = obj.id, name = obj:name() }
          )
        else
          table.insert(
            off_npcs[ map ].monsters, { id = obj.id, name = obj:name() }
          )
        end
      end
    elseif IAmAWeapon[ obj:clsid() ] then
      if obj.m_story_id == 4294967296 and obj.parent_id == 65535 then
        table.insert(
          off_npcs[ map ].weapons, { id=obj.id, name = obj:name() }
        )
      end
    elseif string.find( obj:section_name(), "^af_" ) then
      if obj.parent_id == 65535 then
        table.insert(
          off_npcs[ map ].artefacts, { id = obj.id, name = obj:name() }
        )
      end
    elseif
      (
        obj:clsid() == clsid.inventory_box
        and
        not box_is_protected( obj )
      ) or (
        obj:section_name() == "dsh_treasure_item"
        and
        not protected.ids[ obj.id ]
      )
    then
      table.insert(
        off_npcs[ map ].inv_boxes, { id = obj.id, name = obj:name() }
      )
    end
    if
      obj.parent_id and obj.m_story_id == 4294967296
      and not IAmAMonster[ obj:clsid() ]
      and not IAmAStalker[ obj:clsid() ]
    then
      local zz = alife():object( obj.parent_id )
      if zz then
        if not protected.ids[ obj.parent_id ] then
          if not items[ obj.parent_id ] then items[ obj.parent_id ] = {} end
          table.insert(
            items[ obj.parent_id ],
            {
              id    = obj.id,
              lname = map,
              name  = obj:name(),
            }
          )
        end
        gps_habar.insert_item( obj.parent_id, obj ) -- Idler++-- корректируем хабар в помеченных тайниках
      end
    end
  end
end


--строим таблицу неписей, монстров и оружия
function build_tables()
  -- Почистим таблицу
  rel_enemy, rel_friend = utils.cfg_get_number(
    system_ini(), "game_relations", "goodwill_enemy",  nil, false, -1000
  ),
  utils.cfg_get_number(
    system_ini(), "game_relations", "goodwill_friend", nil, false,  1000
  )
  local s_comm_list = utils.cfg_get_string(
    system_ini(), "game_relations", "communities", nil, false, "", ""
  )
  local comm_list = {}
  local s_value = amk.str_explode( ",", string.trim(s_comm_list), true )
  for a = 1, table.getn( s_value ), 2 do
    local s_comm = s_value[ a ]
    table.insert( comm_list, s_comm )
  end

  local tmp = {}
  local result, id, value = nil, nil, nil
  for a = 0, system_ini():line_count( "communities_relations" ) - 1 do
    result, id, value = system_ini():r_line(
      "communities_relations", a, "", ""
    )
    if id ~= nil and string.trim( id ) ~= "" and string.trim( id ) ~= nil then
      relation_matrix[ string.trim( id ) ] = {}
      table.insert( tmp, string.trim( id ) )
    end
  end

  for a = 1, table.getn( tmp ) do
    local value = utils.cfg_get_string(
      system_ini(), "communities_relations", tmp[ a ], nil, false, "", ""
    )
    local idx = tmp[ a ]
    local m_value = amk.str_explode( ",", string.trim( value ), true )
    for i = 1, table.getn( m_value ) do
      local idx2 = comm_list[ i ]
      local v = m_value[ i ]
      if relation_matrix[ idx ] and idx2 ~= nil and v ~= nil then
        relation_matrix[ idx ][ idx2 ] = tonumber( string.trim( v ) )
      end
    end
  end

  sell_table = {}
  local sini = dsh.cached_ini_file( "misc\\trade_generic.ltx" )
  local cfg_sell = utils.cfg_get_string(
    sini, "trader", "sell_condition", npc, false, false, ""
  )
  if sini and sini:section_exist( cfg_sell ) then
    local result, id, value = nil, nil, nil
    for a = 0, sini:line_count( cfg_sell ) - 1 do
      result, id, value = sini:r_line( cfg_sell, a, "", "" )
      if
        id ~= nil and string.trim( id ) ~= "" and string.trim( id ) ~= nil
        and
        string.trim( value ) ~= "" and string.trim( value ) ~= nil
      then
        -- Добавим в таблицу, что можно продавать.
        sell_table[ id ] = true
      end
    end
  end

  --' Заполняем таблицу зависимостей
  item_dependence = {}
  local n = sys_ini:line_count( "death_generic.item_dependence" )
  local id, value = "", ""
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "death_generic.item_dependence", i, "", "" )
    item_dependence[ id ] = {}
    local vvv = parse_names( value )
    for k,v in pairs( vvv ) do
      item_dependence[ id ][ v ] = true
    end
  end
  --' Предметы, которые нельзя продавать (квестовые например)
  always_keep_item = {}
  local n = sys_ini:line_count( "death_generic.keep_items" )
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "death_generic.keep_items", i, "", "" )
    if value == "true" then
      always_keep_item[ id ] = true
    end
  end

  tables_ready = true
end


function update_npc_tables()
  off_npcs = {}
  local obj
  local sim = alife()
  for a = 1, 65534 do
    obj = sim:object( a )
    if obj then
      add_fresh_meat( obj )
    end
  end
  bFlag = false
  iTime = amk.game_minutes()
  iCounter = 1
end


local weapon_repair_allowed = false
function update_trade()
  if
    ogse_st_mgr.timer_exists(
      script_name() .. ".weapon_repair.forbidden"
    )
  then
    weapon_repair_allowed = false
  else
    weapon_repair_allowed = true
  end
  for a = 1, 65534 do
    local obj = alife():object( a )
    if obj then
      process_trade( obj )
    end
  end
  if weapon_repair_allowed then
    dsh.start_gtimerDHMS(
      script_name() .. ".weapon_repair.forbidden",
      0, math.random( 20, 24 ), 0, 0,
      script_name() .. ".process_weapon_repair_allowed"
    )
    weapon_repair_allowed = false
  end
end


function update_tables( level )
  cleanup_this_level_items( level )
  local ggraph = game_graph()
  local sim    = alife()
  for a = 1, 65534 do
    local obj = sim:object( a )
    if obj then
      if
        ggraph:valid_vertex_id( obj.m_game_vertex_id )
        and
        sim:level_name(
          ggraph:vertex( obj.m_game_vertex_id ):level_id()
        ) == level
      then
        add_fresh_meat( obj )
      elseif obj.parent_id then
        local p_obj = sim:object( obj.parent_id )
        if
          p_obj
          and
          ggraph:valid_vertex_id( p_obj.m_game_vertex_id )
          and
          sim:level_name(
            ggraph:vertex( p_obj.m_game_vertex_id ):level_id()
          ) == level
        then
          add_fresh_meat( obj )
        end
      end
    end
  end
end


function cleanup_this_level_items( lname )
  off_npcs[ lname ] = {
    monsters = {}, stalkers = {}, weapons = {}, artefacts = {}, inv_boxes = {}
  }
  local remove = {}
  for k, v in pairs( items ) do
    if table.getn( v ) > 0 then
      if v[ 1 ].lname == lname then
        remove[ k ] = true
      end
    else
      remove[ k ] = true
    end
  end
  for k, v in pairs( remove ) do
    items[ k ] = nil
  end
end


function trim ( s )
  return ( string.gsub( s, "^%s*(.-)%s*$", "%1" ) )
end


--генерируем оффлайн события
function offline_alife()
  local lname = maps[ math.random( #maps ) ]
  local st = 0
  amk.oau_reason = "cn offline_alife chp1"
  if off_npcs[ lname ] then st = #off_npcs[ lname ].stalkers end
  if st > 0 then
    amk.oau_reason = "cn offline_alife chp2"
    for search = 1, search_intensivity do
      amk.oau_reason = "cn offline_alife chp3"
      local rnd = math.random( st )
      amk.oau_reason = "cn offline_alife chp4"
      if off_npcs[ lname ].stalkers[ rnd ] then 
        amk.oau_reason = "cn offline_alife chp5"
        local victim = alife():object( off_npcs[ lname ].stalkers[ rnd ].id )
        amk.oau_reason = "cn offline_alife chp6"
        if
          victim and not victim.online and victim.health
          and
          victim.can_switch_online and victim:health() > 0
          and
          victim:can_switch_online()
          and victim:name() == off_npcs[ lname ].stalkers[ rnd ].name
        then
          amk.oau_reason = "cn offline_alife chp7 " .. tostring( victim and victim:name() )
          local vdata = collect_info( victim, lname )
          amk.oau_reason = "cn offline_alife chp8 " .. tostring( victim and victim:name() )
         if #vdata.corpses.stalkers > 0 then
            --есть труп сталкера
            amk.oau_reason = "cn offline_alife chp11 " .. tostring( victim and victim:name() )
            on_npc_corpses_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif #vdata.corpses.monsters > 0 then
            --есть труп монстра
            amk.oau_reason = "cn offline_alife chp12 " .. tostring( victim and victim:name() )
            on_monster_corpses_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif #vdata.weapons.seen > 0 then
            --есть бесхозное оружие
            amk.oau_reason = "cn offline_alife chp13 " .. tostring( victim and victim:name() )
            on_weapons_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif #vdata.artefacts > 0 then
            --есть арты
            amk.oau_reason = "cn offline_alife chp14 " .. tostring( victim and victim:name() )
            on_artifacts_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif #vdata.inv_boxes > 0 then
            --есть контейнеры. Надо обыскать.
            amk.oau_reason = "cn offline_alife chp18 " .. tostring( victim and victim:name() )
            on_inv_boxes_found( victim, vdata )
            break   --прерываем цикл - событие отработано
          elseif items[ victim.id ] and #items[ victim.id ] > 0 then
            --попробуем продать всякого
            amk.oau_reason = "cn offline_alife chp15 " .. tostring( victim and victim:name() )
            amk.oau_reason = "cn offline_alife chp17 " .. tostring( victim and victim:name() )
            process_trade( victim )
            break
          end
        end
      end
    end
  end
  amk.oau_reason = "cn offline_alife end"
end


--собираем инфу о неписе
function collect_info( victim, map )
  local vdata = {}
  vdata.rank      = victim:rank() --ранг
  vdata.health    = victim:health()  --хелсы
  vdata.community = victim:community()  --группировка

  --пытаемся определить пушку
  local wp = #off_npcs[ map ].weapons
  --условная огневая мощь
  vdata.fire_power = 0

  local sim = alife()
  vdata.weapons = { own={},seen={} }
  -- если есть пушки в карманах, выбираем лучшую (по условной мощности)
  if wp > 0 then
    for w = 1, wp do
      if off_npcs[ map ].weapons[ w ] then
        local www = sim:object( off_npcs[ map ].weapons[ w ].id )
        if www and www:name() == off_npcs[ map ].weapons[ w ].name then
          if www.parent_id == victim.id then
            table.insert(
              vdata.weapons.own, { id = www.id, name = www:name() }
            )
            local fp = get_weapon_firepower( www )
            if vdata.fire_power < fp then vdata.fire_power = fp end
          elseif
            www:can_switch_online()
            and
            victim.position:distance_to( www.position ) < look_radius
            and
            sobj_is_far( www, to_actor )
          then
            -- ОП-2: Фикс пропадания стволов из нычки. Стволы в нычке больше не видимы для неписей.
            if www.parent_id == nil or www.parent_id == 65535 then
              table.insert(
                vdata.weapons.seen, { id = www.id, name = www:name() }
              )
            end
          end
        end
      end
    end
  end

  --составляем списки друзей и врагов в зоне "видимости"
  -- Для тех, у кого смарт в фильтрах - не собираем врагов
  -- Для остальных - не учитываем врагов из смартов
  local npc_peaceful = npc_smart_is_peaceful( victim )

  vdata.friends = {}
  vdata.enemies = {}
  vdata.corpses = { monsters = {},stalkers = {} }
  if #off_npcs[ map ].stalkers > 0 then
    for a = 1, #off_npcs[ map ].stalkers do
      if off_npcs[ map ].stalkers[ a ] then
        local opponent = sim:object( off_npcs[ map ].stalkers[ a ].id )
        if
          opponent and opponent.id ~= victim.id
          and
          opponent.health
          and
          opponent.can_switch_online and opponent:can_switch_online()
          and
          opponent:name() == off_npcs[ map ].stalkers[ a ].name
        then
          if victim.position:distance_to( opponent.position ) < look_radius then
            if opponent:health() > 0 then
              local rel = relation_check( victim, opponent )
              if rel >= rel_friend then
                table.insert(
                  vdata.friends, { id = opponent.id, name = opponent:name() }
                )
              elseif rel <= rel_enemy then
                if
                  npc_peaceful == false
                  and
                  npc_smart_is_peaceful( opponent ) == false
                then
                  table.insert(
                    vdata.enemies, { id = opponent.id, name = opponent:name() }
                  )
                end
              end
            else
              if ( sobj_is_far( opponent, to_actor ) ) then
                table.insert(
                  vdata.corpses.stalkers, { id = opponent.id, name = opponent:name() }
                )
              end
            end
          end
        end
      end
    end
  end

  --составляем список монстряков в зоне "видимости"
  vdata.monsters = {}
  if off_npcs[ map ].monsters then
    if #off_npcs[ map ].monsters > 0 then
      for a = 1, #off_npcs[ map ].monsters do
        if off_npcs[ map ].monsters[ a ] then
          local monster = sim:object( off_npcs[ map ].monsters[ a ].id )
          if
            monster and monster.health
            and
            monster.can_switch_online and monster:can_switch_online()
            and
            monster:name() == off_npcs[ map ].monsters[ a ].name
            and
            victim.position:distance_to( monster.position ) < look_radius
          then
            if monster:health() > 0 then
              table.insert(
                vdata.monsters, { id = monster.id, name = monster:name() }
              )
            else
              if ( sobj_is_far( monster, to_actor ) ) then
                table.insert(
                  vdata.corpses.monsters, { id = monster.id, name = monster:name() }
                )
              end
            end
          end
        end
      end
    end
  end

  --составляем список артов в зоне "видимости"
  vdata.artefacts = {}
  if off_npcs[ map ].artefacts then
    if #off_npcs[ map ].artefacts > 0 then
      for a = 1, #off_npcs[ map ].artefacts do
        if off_npcs[ map ].artefacts[ a ] then
          local artefact = sim:object( off_npcs[ map ].artefacts[ a ].id )
          if
            artefact
            and
            artefact.can_switch_online and artefact:can_switch_online()
            and
            artefact:name() == off_npcs[ map ].artefacts[ a ].name
            and
            victim.position:distance_to( artefact.position ) < look_radius
            and
            sobj_is_far( artefact, to_actor )
          then
            if
              artefact.parent_id == nil or artefact.parent_id == 65535
              or (
                sim:object( artefact.parent_id )
                and (
                  sim:object( artefact.parent_id ):clsid() == clsid.inventory_box
                  or
                  amk_anoms.is_anomaly( sim:object( artefact.parent_id ):clsid() )
                )
              )
            then
              table.insert(
                vdata.artefacts, { id = artefact.id, name = artefact:name() }
              )
            end
          end
        end
      end
    end
  end

  --составляем список контейнеров в зоне "видимости"
  vdata.inv_boxes = {}
  if off_npcs[ map ].inv_boxes then
    if #off_npcs[ map ].inv_boxes > 0 then
      for a = 1, #off_npcs[ map ].inv_boxes do
        if off_npcs[ map ].inv_boxes[ a ] then
          local inv_box = sim:object( off_npcs[ map ].inv_boxes[ a ].id )
          if
            inv_box and inv_box.can_switch_online and inv_box:can_switch_online()
            and
            inv_box:name() == off_npcs[ map ].inv_boxes[ a ].name
            and
            victim.position:distance_to( inv_box.position ) <= look_radius_box
            and
            sobj_is_far( inv_box, to_actor )
          then
            local zdist = victim.position:distance_to( inv_box.position ) / 100
            if math.random() > zdist then
              if inv_box.parent_id == nil or inv_box.parent_id == 65535 then
                table.insert(
                  vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() }
                )
              end
            end
          end
        end
      end
    end
  end

  return vdata
end


-- получаем отношение группировки к неписю, в оффлайне фактически
-- равно личным отношениям неписей
function relation_check( victim, opponent )
  if
    relation_matrix[ opponent:community() ]
    and
    relation_matrix[ opponent:community() ][ victim:community() ]
  then
    return relation_matrix[ opponent:community() ][ victim:community() ]
  else
    return 0
  end
end


-- О, трупик. Щас шмонать будем.
function on_npc_corpses_found(victim, vdata)
        if (victim == nil or vdata == nil) then return end
        if (vdata.corpses == nil) then return end
        if (vdata.corpses.stalkers == nil) then return end
        if (amk.is_debug == true) then
                local lname = news_main.get_object_levelname(victim)
                local s = "found stalker's corpse ("..#vdata.corpses.stalkers..") for "..victim.id.." ["..victim:community().."] on map "..lname
                amk.mylog(s)
        end
        local obj, v_obj
        local id
        local v_id = victim.id
        for i=1, #vdata.corpses.stalkers do
                v_obj = vdata.corpses.stalkers[i]
                local corpse = alife():object(v_obj.id)
                if (corpse and corpse:name() == v_obj.name) then
                        news_main.on_offline_corpse_found(victim, corpse)
                        id = corpse.id
                        if (id and items[id]) then
                                for a=1, #items[id] do
                                        local v_itA = items[id][a]
                                        if (v_itA) then
                                                local itA = alife():object(v_itA.id)
                                                if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
                                                        local l_objA = pick_item(victim, itA)
                                                end                     
                                        end
                                end
                        end
                end
        end
        process_trade(victim)
end


-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata)
        if (victim == nil or vdata == nil) then return end
        if (vdata.corpses == nil) then return end
        if (vdata.corpses.monsters == nil) then return end
        if (amk.is_debug == true) then
                local lname = news_main.get_object_levelname(victim)
                local s = "found monster's corpse ("..#vdata.corpses.monsters..") for "..victim.id.." ["..victim:community().."] on map "..lname
                amk.mylog(s)
        end
        local obj, v_obj
        local object
        local id
        local v_id = victim.id
        for i=1, #vdata.corpses.monsters do
                v_obj = vdata.corpses.monsters[i]
                local corpse = alife():object(v_obj.id)
                if (corpse and corpse:name() == v_obj.name) then
                        news_main.on_offline_corpse_found(victim, corpse)               
                        id = corpse.id
                        if (id and items[id]) then
                                for a=1, #items[id] do
                                        local v_itA = items[id][a]
                                        if (v_itA) then
                                                local itA = alife():object(v_itA.id)
                                                if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
                                                        local l_objA = pick_item(victim, itA)
                                                end                     
                                        end
                                end
                        end
                end
        end
        process_trade(victim)
end


-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
        if (victim == nil or vdata == nil) then return end
        if (amk.is_debug == true) then
                local lname = news_main.get_object_levelname(victim)
                local s = "found weapons ("..#vdata.weapons.seen..") for "..victim.id.." on map "..lname
                amk.mylog(s)
        end
        local obj, v_obj
        local object
        local v_id = victim.id
        for i=1, #vdata.weapons.seen do
                v_obj = vdata.weapons.seen[i]
                if (v_obj) then
                        object = alife():object(v_obj.id)
                        if (object and object:name() == v_obj.name) then
                                obj = pick_item(victim, object)
                        end
                end
        end
        process_trade(victim)
end


-- Моя прелесссть
function on_artifacts_found(victim, vdata)
        if (victim == nil or vdata == nil) then return end
        local obj, v_obj
        local object
        local v_id = victim.id
        local b_stalker = false
        -- Если сталкер - дадим опыт.
        if victim and IAmAStalker[victim:clsid()] and victim.community then
                local m_comm  = victim:community()
                if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
                        b_stalker = true
                end
        end
        for i=1, #vdata.artefacts do
                v_obj = vdata.artefacts[i]
                if (v_obj) then
                        object = alife():object(v_obj.id)
                        if (object and object:name() == v_obj.name) then
                                obj = pick_item(victim, object)
                                if (obj) then
                                        if (b_stalker == true) then
                                                victim:set_rank(victim:rank() + rate_art_found)
                                        end
                                end
                        end
                end
        end
        process_trade(victim)
end


-- О, нычка - это гуд.  Idler ++ проверим, а сможет ли непись долезть
-- до тайника.  если есть аномалии в радиусе 20м, меньше шансов или
-- если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail( victim, box )
  if (victim == nil or box == nil or box.id == 0) then return false end

  -- отсекаем сюжетные тайники
  if
    transparent_treasure.IsTaken( box:section_name() )
    and
    box:section_name() ~= "m_inventory_box"
  then
    return false
  end

  local n_rnd
  if victim.position and box.position then
    n_rnd = math.random( 2, 5 )
    if math.abs( box.position.y - victim.position.y ) > n_rnd then
      return false
    end
  end

  local anom_list=amk_anoms.get_anomaly_list_for_pos( box.position, 20 )
  local n_anoms = #anom_list
  n_rnd = math.random( 1, 100 )
  if n_rnd < n_anoms * 20 then -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При 5 - точно до ящика не доберется
    return false
  end

  return true
end
-- Idler --


function on_inv_boxes_found( victim, vdata )
  if ( victim == nil or vdata == nil ) then return end
  local obj, v_obj
  local object
  local v_id = victim.id
  local b_stalker = false
  -- Если сталкер - дадим опыт.
  if victim and IAmAStalker[ victim:clsid() ] and victim.community then
    local m_comm = victim:community()
    if stalkers_comm[ m_comm ] then
      b_stalker = true
    end
  end
  for i = 1, #vdata.inv_boxes do
    v_obj = vdata.inv_boxes[ i ]
    if v_obj then
      object = alife():object( v_obj.id )
      if ( object and object:name() == v_obj.name ) then
        if inv_box_is_avail( victim, object ) then  -- Idler ++-- если нычка доступна - можно шмонать
          if object:section_name() == "dsh_treasure_item" then
            dsh_rukzak.on_inv_box_found( object.id, victim )
          elseif items[ v_obj.id ] and #items[ v_obj.id ] > 0 then
            for a = 1, #items[ v_obj.id ] do
              local v_itA = items[ v_obj.id ][ a ]
              if v_itA then
                local itA = alife():object( v_itA.id )
                if ( itA and itA:name() == v_itA.name and itA.parent_id == v_obj.id ) then
                  -- Решим, подбираем или нет?
                  local bTake = is_valuable( itA )
                  if bTake then
                    local l_objA = pick_item( victim, itA )
                  end
                else
                  if itA then
                    local mm = itA.parent_id
                    if mm == nil then mm = "nil" end
                  end
                end
              end
            end
          end
          if b_stalker then
            victim:set_rank( victim:rank() + rate_art_found )
          end
        end
      end
    end
  end
  process_trade( victim )
end


function pick_item( npc, obj )
  local new = nil
  if ( npc and obj and db.actor and obj.id ~= db.actor:id() ) then
    local section = obj:section_name()
    new = alife():create(
      section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
    )
    if new then
      if new.parent_id then
        if not items[ new.parent_id ] then items[ new.parent_id ] = {} end
        table.insert(
          items[ new.parent_id ], { id = new.id, name = new:name() }
        )
        gps_habar.insert_item( new.parent_id, new ) -- Idler++-- корректируем хабар в помеченных тайниках
      end
      if ( obj.parent_id and items[ obj.parent_id ] and #items[ obj.parent_id ] > 0 ) then
        for z = 1, #items[ obj.parent_id ] do
          if ( items[ obj.parent_id ][ z ] and items[ obj.parent_id ][ z ].id == obj.id ) then
            gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] ) -- Idler++-- корректируем хабар в помеченных тайниках
            table.remove( items[ obj.parent_id ], z )
            break
          end
        end
      end
      alife():release( alife():object( obj.id ), true )
    end
  end
  return new
end


function get_npc_weapon(npc)
        local obj = nil
        local fp = 0
        if (npc) then
                        if items[npc.id] ~= nil and items ~= nil and npc.id ~= nil then -- заплатка от вылета //[fR4g]
                         for k,v in pairs(items[npc.id]) do --- вылет был тут
                        local wpn = alife():object(v.id)
                                if wpn and IAmAWeapon[wpn:clsid()] and wpn:name() == v.name and wpn.parent_id == npc.id then
                                local sect = wpn:section_name()
                                local cur_fp = 0                                
                                local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
                                local params = rx_wmgr.read_wpn_params(sect)
                                if modes.mode1 == "1" then
                                        cur_fp = params.cst + modes.addcost
                                elseif modes.mode1 == "2" then
                                        local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
                                        cur_fp = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
                                elseif modes.mode1 == "3" then
                                        cur_fp = rx_wmgr.wm_modes.priors[modes.priors][sect] or 0
                                end
                                if cur_fp > fp then
                                        fp = cur_fp
                                        obj = wpn
                                end                     
                        end
                     end
                      end
        end
        return obj
end


function get_weapon_firepower(wpn)
        local result = 0
        if wpn and IAmAWeapon[wpn:clsid()] then
                local sect = wpn:section_name()
                if wpn_fp[sect] then
                        result = wpn_fp[sect]
                else
                if not (sect == "grenade_f1" or sect =="grenade_gd-05" or sect == "grenade_rgd5" or sect == "grenade_flash") then
                        --local fd = utils.cfg_get_number(system_ini(), wpn:section_name(), "fire_distance", wpn, false, 1)
                        --local bs = utils.cfg_get_number(system_ini(), wpn:section_name(), "bullet_speed", wpn, false, 1)
                        --local rpm = utils.cfg_get_number(system_ini(), wpn:section_name(), "rpm", wpn, false, 1)
                        local priority = utils.cfg_get_number(system_ini(), wpn:section_name(), "ef_weapon_type", wpn, false, 1)
                        local priority2 = utils.cfg_get_number(system_ini(), wpn:section_name(), "ef_main_weapon_type", wpn, false, 0)
                        local GetRPM = ui_wpn_params.GetRPM(wpn:section_name())
                        local GetDamage = ui_wpn_params.GetDamage(wpn:section_name())
                        local GetHandling = ui_wpn_params.GetHandling(wpn:section_name())
                        local GetAccuracy = ui_wpn_params.GetAccuracy(wpn:section_name())
                        local fp = 1
                        if priority>1 and priority2>0 then
                                priority = priority + priority2
                        end
                        --fp = priority*1000 + math.sqrt(fd*bs*rpm)             
                        fp = math.ceil(priority * 1000 + GetAccuracy * 100 + GetRPM * 3 + GetDamage * 8) - 5000
                        if GetHandling >= 99 then
                                fp = fp + 1500
                        end
                        result = fp
                                if wpn_fp[sect] == nil then
                                        wpn_fp[sect] = fp
                                end
                        end
                end
        end
        return result
end


function get_weapon_cost(weapon)
        local result = 0
        if (weapon and isWeapon(weapon)) then
                result = utils.cfg_get_number(system_ini(), weapon:section_name(), "cost", weapon, false, 0)
        end
        return result
end

function get_item_cost(item)
        local result = 0
        if (item and item.section_name) then
                result = utils.cfg_get_number(system_ini(), item:section_name(), "cost", item, false, 0)
                local params = m_net_utils.get_item_data( item )
                if params.condition > 0 then
                        result = result * params.condition
                else
                        result = 1
                end
        end
        return result
end


--[=[
Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.
Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class + item_dependence
Оставили одно, которое лучше (а), но патронов нет (б) (%)
Одно, которое лучше (а), но хуже (б) - в новости на продажу
Остальное на продажу
Патроны оставили только те, что подходят к (а), остальные на продажу
Для вояк - только родной калаш надо бы... Не продавать вобще?
Оставляем не более 2 аптечек и бинтов, антирада
Оставляем 1-2 гранаты (%)
Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
Еда, водка - не более 1-2 шт (%)
Броники наверное продаем...
Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
--]=]
function process_trade( npc )
  local item_list = {}
  local sell_list = {}
  local tb_ilist_size = table.getn( item_list )
  -- Имеет смысл проверять на наличие trade в секции [logic]...
  if
    npc and IAmAStalker[npc:clsid()] and npc:alive()
    and npc.m_story_id ~= nil and npc.m_story_id == 4294967296
    and ( not xr_companion.is_companion( npc.id ) )
    and items[ npc.id ] and table.getn( items[ npc.id ] ) > 0
    and ( not protected_items.is_no_offline_alife_npc( npc:section_name() ) )
  then
    local m_comm = npc:community()
    local b_stalker = false
    if stalkers_comm[ m_comm ] then
      if npc.name and npc:name() ~= "agr_ratcatcher" then
        b_stalker = true
      end
    elseif m_comm == "zombied" then
      return
    end

    --Фильтруем квестовые items - always_keep_item, sell_table
    for _, ov in ipairs( items[ npc.id ] ) do
      local obj = alife():object( ov.id )
      if obj and obj:name() == ov.name then
        if
          not (
            always_keep_item[ obj:section_name() ]
            or protected_items.actor_items_keep( obj:section_name() )
          )
        then
          table.insert( item_list, obj )
        end
      end
    end

    if item_list and table.getn( item_list ) > 0 then
      table.sort(
        item_list,
        function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
      )
      -- Выберем, что за оружие оставит себе NPC.
      local cnt_medkit    = 0
      local cnt_antirad   = 0
      local cnt_bandage   = 0
      local cnt_grenade   = 0
      local cnt_food      = 0
      local cnt_drink     = 0
      local cnt_torch     = 0
      local cnt_pda       = 0
      local cnt_radio     = 0
      local cnt_guitar    = 0
      local cnt_harmonica = 0
      local cnt_binocular = 0
      local cnt_knife     = 0
      local cnt_arts      = 0
      local cnt_detector  = 0
      local cnt_addons    = 0
      local cnt_mparts    = 0
      local weapons       = {}
      local ammo          = {}
      for _, v in ipairs( item_list ) do
        local sect = v:section_name()
        if
          sect == "grenade_f1"
          or sect =="grenade_gd-05"
          or sect == "grenade_rgd5"
          or sect == "grenade_flash"
          or sect == "grenade_f1_double"
          or sect == "grenade_m61"
        then
          cnt_grenade = cnt_grenade + 1
          if cnt_grenade > 2 then
            table.insert( sell_list, v )
          end
        elseif
          string.find( sect, "^wpn_addon_scope" )
          or string.find( sect, "^wpn_addon_silencer" )
          or string.find( sect, "^wpn_addon_grenade_launcher" )
        then
          cnt_addons = cnt_addons + 1
          if cnt_addons > 2 then
            table.insert( sell_list, v )
          end
        elseif sect == "wpn_knife" then
          cnt_knife = cnt_knife + 1
          if cnt_knife > 1 then
            table.insert( sell_list, v )
          end
        elseif isWeapon( v ) then
          local ac = get_string( sect, "ammo_class" )
          if ac and ac ~= "" then
            table.insert( weapons, { obj = v, ammo = parse_names( ac ) } )
          else
            table.insert( weapons, { obj = v } )
          end
        elseif string.find( sect, "^ammo_" ) then
          if ammo[ sect ] then
            table.insert( ammo[ sect ].objs, v )
          else
            ammo[ sect ] = { objs = { v } }
          end
        elseif string.find( sect, "^af_" ) then
          -- 3 самых хороших арта оставили себе (+здоровье), остальные
          -- на продажу ( фильтруем булыжник )
          if sect ~= "af_buliz" then
            cnt_arts = cnt_arts + 1
            if cnt_arts > 3 then
              table.insert( sell_list, v )
            end
          end
        elseif sect == "device_torch" then
          cnt_torch = cnt_torch + 1
          if cnt_torch > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "device_pda" then
          cnt_pda = cnt_pda + 1
          if cnt_pda > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "hand_radio" then
          cnt_radio = cnt_radio + 1
          if cnt_radio > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "harmonica_a" then
          cnt_harmonica = cnt_harmonica + 1
          if cnt_harmonica > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "guitar_a" then
          cnt_guitar = cnt_guitar + 1
          if cnt_guitar > 1 then
            table.insert( sell_list, v )
          end
        elseif sect == "binocular_a" or sect == "wpn_binoc" then
          cnt_binocular = cnt_binocular + 1
          if cnt_binocular > 1 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "medkit"
          or sect == "medkit_army"
          or sect == "medkit_scientic"
        then
          cnt_medkit = cnt_medkit + 1
          if cnt_medkit > 4 then
            table.insert( sell_list, v )
          end
        elseif sect == "antirad" then
          cnt_antirad = cnt_antirad + 1
          if cnt_antirad > 3 then
            table.insert( sell_list, v )
          end
        elseif sect == "bandage" then
          cnt_bandage = cnt_bandage + 1
          if cnt_bandage > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "bread_a"
          or sect =="bread"
          or sect == "kolbasa"
          or sect == "kolbasa_a"
          or sect == "conserva"
        then
          cnt_food = cnt_food + 1
          if cnt_food > 4 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "vodka_a"
          or sect =="vodka"
          or sect == "energy_drink"
        then
          cnt_drink = cnt_drink + 1
          if cnt_drink > 3 then
            table.insert( sell_list, v )
          end
        elseif
          sect == "detector_simple"
          or sect =="detector_advances"
          or sect == "detector_elite"
        then
          cnt_detector = cnt_detector + 1
          if cnt_detector > 1 then
            table.insert( sell_list, v )
          end
        elseif string.find( sect, "^mutant_" ) then
          cnt_mparts = cnt_mparts + 1
          if cnt_mparts > 2 then
            table.insert( sell_list, v )
          end
        elseif string.find( sect, "outfit" ) or string.find( sect, "exo" ) then
          table.insert( sell_list, v )
        end
      end

      local modes = rx_wmgr.read_wm_modes(
        npc:community(), ranks.get_obj_rank_name( npc ), npc:section_name()
      )
      local weapons_types = {}
      for _, i in ipairs( modes.types ) do
        weapons_types[ i.t ] = {}
      end
      for _, w in ipairs( weapons ) do
        local sect   = w.obj:section_name()
        local params = rx_wmgr.read_wpn_params( sect )
        local t      = { obj = w.obj, ammo = w.ammo, prm = 0 }
        if modes.mode1 == "1" then
          t.prm = params.cst + modes.addcost
        elseif modes.mode1 == "2" then
          local kf = rx_wmgr.wm_modes.koeffs[ modes.koeffs ]
          t.prm = ( params.dmg * kf.dmg )
            + ( params.rpm * kf.rpm )
            + ( params.dst * kf.dst )
            + ( ( 100 / params.dsp ) * kf.dsp )
        elseif modes.mode1 == "3" then
          t.prm = rx_wmgr.wm_modes.priors[ modes.priors ][ sect ] or 0
        end
        local pk = xs_netpk.weapon( t.obj )
        ASSERT(
          pk:isOk(), "[%s]: can't parse netpk: %s",
          script_name(), t.obj:name()
        )
        local data = pk:get()
        t.cond   = data.condition
        t.has_gl = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.gl
        ) ~= 0
        t.has_scope = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.scope
        ) ~= 0
        t.has_silencer = bit_and(
          data.addon_flags, ogse_wpn_utils.addons_flags.silencer
        ) ~= 0
        local pr = 0
        if t.has_gl then
          pr = pr + t.prm * modes.grenadelauncher / 100
        end
        if t.has_scope then
          pr = pr + t.prm * modes.scope / 100
        end
        if t.has_silencer then
          pr = pr + t.prm * modes.silencer / 100
        end
        for _, v in ipairs( modes.types ) do
          if v.t == params.typ then
            pr = pr + t.prm * v.p / 100
            break
          end
        end
        t.prm = t.prm + pr + w.obj.id / 100000 + t.cond * t.prm / 50
        if weapons_types[ params.typ ] then
          table.insert( weapons_types[ params.typ ], t )
        else
          weapons_types[ params.typ ] = { t }
        end
      end

      local our_weapons = {}
      for k, v in pairs( weapons_types ) do
        table.sort(
          v, function( a, b ) return a.prm > b.prm end
        )
        -- Так, теперь у нас отсортированны все пушки НПС. Найдем ту,
        -- для которой есть патроны...
        local b_self = false
        local b_best = false
        local s_self = ""
        for _, w in ipairs( v ) do
          local b_ammo = false
          local vac    = w.ammo
          if vac and table.getn( vac ) > 0 then
            for kk, vv in ipairs( vac ) do
              if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
                -- Так, патроны есть.
                b_ammo = true
                break
              end
            end
          end
          if is_broken_wpn( w ) then
            table.insert( sell_list, w.obj )
          elseif b_self == false and b_ammo == true then
            b_self = true
            s_self = w.obj:section_name()
            table.insert( our_weapons, w )
          elseif b_best == false then
            if s_self ~= "" then
              if w.obj:section_name() ~= s_self then
                b_best = true
                table.insert( our_weapons, w )
              else
                table.insert( sell_list, w.obj )
              end
            else
              b_best = true
              table.insert( our_weapons, w )
            end
          else
            table.insert( sell_list, w.obj )
          end
        end
      end
      process_ammo_trade( sell_list, ammo, npc, our_weapons )
      if weapon_repair_allowed then
        process_weapon_repair( our_weapons )
      end

      -- Так, с оружием закончили...
      -- Все, что осталось - надо продать.
      -- 1 самое дорогое можно попробовать через новости...
      -- ... ну и когда-нибудь, как фишка ляжет, наконец от него избавиться.
      local money = 0
      if sell_list and table.getn( sell_list ) > 0 and math.random() > 0.1 then
        table.sort(
          sell_list,
          function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end
        )
        local zz = sell_list[ 1 ]
        if zz and b_stalker == true and get_item_cost( zz ) >= sell_limit then
          -- Продадим через новости.
          news_main.on_offline_trade( npc, zz )
          table.remove( sell_list, 1 )
        end
      end
      for _, vv in ipairs( sell_list ) do
        local cost = get_item_cost( vv )
        if cost > 0 then
          local coeff = math.random( 30, 50 ) / 100
          local price = math.floor( cost * coeff )
          money = money + price
          -- Почистим items
          if items[ npc.id ] and table.getn( items[ npc.id ] ) > 0 then
            for z, item in ipairs( items[ npc.id ] ) do
              if item.id == vv.id then
                table.remove( items[ npc.id ], z )
                -- Idler++-- корректируем хабар в помеченных тайниках
                gps_habar.remove_item( npc.id, item )
                break
              end
            end
          end
          alife():release( alife():object( vv.id ), true )
        end
      end
      if money > 0 then
        local pk = xs_netpk.stalker( sobj )
        if pk:isOk() then
          local data = pk:get()
          if data.money then money = money + data.money end
          data.money = money
          pk:set( data )
        end
      end
    end
  end
end


function process_ammo_trade( sell_list, ammo, npc, our_weapons )
  for _, w in ipairs( our_weapons ) do
    local vac = w.ammo
    if vac and table.getn( vac ) > 0 then
      for _, vv in ipairs( vac ) do
        if ammo[ vv ] and table.getn( ammo[ vv ].objs ) > 0 then
          ammo[ vv ].inuse = true
        end
      end
    end
  end
  for sect, v in pairs( ammo ) do
    if table.getn( v.objs ) > 2 then
      table.sort(
        v.objs,
        function( a, b )
          return get_ammo_size( a ) > get_ammo_size( b )
        end
      )
      while table.getn( v.objs ) > 2 do
        table.insert( sell_list, table.remove( v.objs ) )
      end
    end
    if table.getn( v.objs ) > 0 then
      if v.inuse then
        local box_size = get_u32( sect, "box_size" )
        for _, sobj in ipairs( v.objs ) do
          local data = m_net_utils.get_ammo_data( sobj )
          if data.ammo_left < box_size then
            data.ammo_left = box_size
            m_net_utils.set_ammo_data( data, sobj )
          end
        end
      end
    end
  end
end


function get_ammo_size( sobj )
  local data = m_net_utils.get_ammo_data( sobj )
  return data.ammo_left
end


function is_broken_wpn( w )
  return w.cond < rx_wmgr.wm_modes.min_cond
end


function process_weapon_repair( our_weapons )
  for _, w in ipairs( our_weapons ) do
    if w.cond < 1 then
      local data = m_net_utils.get_weapon_data( w.obj )
      if data.condition < 0.9 then
        data.condition = data.condition + 0.1
      else
        data.condition = 1
      end
      m_net_utils.set_weapon_data( data, w.obj )
      w.cond = data.condition
    end
  end
end
function process_weapon_repair_allowed() end


function sobj_is_far(obj, distance)
        local result = true
        if (db.actor and obj and distance and obj.position and db.actor.position ) then
                -- на одном ли уровне?
                if obj.m_game_vertex_id and game_graph():valid_vertex_id(obj.m_game_vertex_id) then
                local map = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
                if (map and level.name() == map) then
                        -- Достаточно ли далеко?
                        if (obj.position:distance_to(db.actor:position()) < distance) then
                                result = false
                        end
                end
   end
   end
   return result
end


function box_is_protected(v)
        if v then
                local name = v:name()
                local id = v.id
                local sid = v.m_story_id
                local sec = v:section_name()
                
                -- проверяем по ID объекта
                if protected.ids[ id ] then return true end
                
                -- проверяем по имени объекта
                for k, o in pairs(protected.names) do
                        if o == name then
                                return true
                        end
                end
                
                -- проверяем по story ID объекта
                for k, o in pairs(protected.story_ids) do
                        if o == sid then
                                return true
                        end
                end

                -- проверяем по секции объекта
                for k, o in pairs(protected.sections) do
                        if o == sec then
                                return true
                        end
                end
        end
        return false
end


function npc_smart_is_peaceful(sobj)
        local result = false
        if (sobj and smart_filters and #smart_filters>0) then
                if (sobj.smart_terrain_id and sobj:smart_terrain_id() and sobj:smart_terrain_id()~=65535) then
                        local sm = alife():object(sobj:smart_terrain_id())
                        if (sm and sm.name and sm:name()) then
                                local sn = sm:name()
                                for ks, vs in pairs(smart_filters) do
                                        if (vs == sn) then
                                                -- Ага, он у нас мирный.
                                                result = true
                                                break
                                        end
                                end
                        end
                end
        end
        return result
end


function get_flags(npc_id)
        local flags = 0
        local obj = alife():object(npc_id)
        if obj then
                if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
                        local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
                        if char_ini:section_exist("logic") then
                                local from = ""
                                local items = ""
                                if char_ini:line_exist("logic", "on_hit") then
                                        flags = 1
                                end
                                if char_ini:line_exist("logic", "on_death") then
                                        flags = flags + 2
                                end
                        end
                end
        end
        return flags
end


function is_valuable( item )
  local result = false
  if
    item
    and
    not ( IAmAMonster[ item:clsid() ] or IAmAStalker[ item:clsid() ] )
    and
    not protected_items.actor_items_keep( item:section_name() )
  then
    -- Уники не подбираем (пока?)
    if
      always_keep_item[ item:section_name() ]
      or
      sell_table[ item:section_name() ] == nil
    then
      return false
    end
    local cost = get_item_cost( item )
    if IAmAWeapon[ item:clsid() ] and cost >= 1000 then
      result = true
    elseif cost >= 800 then
      result = true
    end
  end
  return result
end
