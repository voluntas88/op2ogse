-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--- ogse_surge_mgr.script
--- Модуль выброса для OGSE
--- (c) OGS Evolution Team, 2014
-------------------------------------------------------------------------------

function attach(sm) -- для менеджера сигналов
	sm:subscribe({signal = "on_update",          fun = this.on_actor_update})
	sm:subscribe({signal = "on_first_update",    fun = this.on_first_update})
	sm:subscribe({signal = "on_info",            fun = this.on_get_info})
	sm:subscribe({signal = "on_spawn",           fun = this.on_actor_spawn})
end
local debug_logging = get_console():get_bool("write_debug_log")
local fsurgelog = nil

local aux_counter = 0
function surge_log(f,...)
	if not debug_logging then return end
	if not fsurgelog then
		local surge_log_path = getFS():update_path("$logs$", "surge_log_"..get_game_id()..".txt")
		fsurgelog = io.open(surge_log_path, "a")
	end
	local time_str = time2string(game.get_game_time(), "%04d/%02d/%02d %02d:%02d:%02d.%03d", {'y','m','d','h','min','s','ms'})
	local cntr_str = string.format(" %03d] ", aux_counter)
	fsurgelog:write('['..time_str..cntr_str..f:format(...)..'\n')
	aux_counter = aux_counter + 1
	--fsurgelog:write('\n')
	fsurgelog:flush()
end

local first_surge_wait_time = 72 --get_float("options", "t_first_surge") -- время от начала игры до первого выброса, час.
local first_surge_time_disp = 12 -- разброс времени первого выброса, час.
local base_surge_wait_time  = 72 --get_float("options", "t_surge") -- среднее время между выбросами, час.
local surge_wait_time_disp  = 12 -- разброс времени ожидания, час.
local surge_postpone_time   = 10 -- [час.], время откладывания выброса в случае невозможности его начать по сюжетным ограничениям
local horror_flag           = sys_ini:r_s32("options","horror_flag")
local psyzones_flag         = sys_ini:r_s32("options","psyzones_flag")
local horror_time_proshow   = sys_ini:r_s32("options","horror_time_proshow")

local sound_obj_right = xr_sound.get_safe_sound_object([[ambient\random\rnd_the_horror]])
local sound_obj_left = xr_sound.get_safe_sound_object([[ambient\random\rnd_the_horror]])


local military_phantom_types = {
	"phantom_krovosos_1",
	"phantom_kontroler_1", 
	"phantom_pseudodog_1", 
	"phantom_psevdogigant_1", 
	"phantom_chimera_1", 
	"phantom_zombi_3", 
	"boar_phantom_2", 
	"zombie_phantom_2", 
	"dog_phantom_2", 
	"flesh_phantom_2"
	}
	
local escape_phantom_types = {
	"phantom_flesh_1",
	"phantom_mutant_boar_1", 
	"phantom_dog_1", 
	"phantom_cat_1", 
	"phantom_tushkano_1", 
	"phantom_zombi_3", 
	"boar_phantom_2", 
	"zombie_phantom_2", 
	"dog_phantom_2", 
	"flesh_phantom_2"
	}
	
local zombi_types = {
	"zombie_weak",
	"zombie_strong", 
	"zombie_normal", 
	"zombie_v_strong", 
	"zombie_v_normal", 
	"zombie_immortal", 
	"rat_weak",  
	"zombie_plague", 
	"zombie_ghost", 
	"zombie_old" 
	}
	
local cat_types = {
	"cat_v_normal",
	"cat_weak", 
	"cat_v_strong" 
	}
	
local anomaly = {
	"electra_movable1",
	"jarka_movable" 
	}
	
local dog_types = {
	"dog_weak",
	"dog_normal", 
	"dog_strong", 
	"dog_v_strong", 
	"pseudodog_weak", 
	"pseudodog_normal", 
	"pseudodog_strong",  
	"pseudodog_v_strong", 
	"phantom_dog_1" 
	}
	
local claw_types = {
	"boar_weak",
	"boar_normal", 
	"boar_strong", 
	"flesh_weak", 
	"flesh_normal", 
	"flesh_strong", 
	"flesh_v_strong" 
	}
	
local snork_types = {
	"phantom_snork_1",
	"snork_weak", 
	"snork_normal", 
	"snork_strong", 
	"phantom_snork_4" 
	}
	
local hard_monsters_types = {
	"phantom_krovosos_1",
	"phantom_krovosos_2", 
	"gigant_normal", 
	"gigant_strong", 
	"chimera_weak", 
	"chimera_strong", 
	"bloodsucker_weak", 
	"bloodsucker_normal", 
	"bloodsucker_normal",
	"bloodsucker_strong",
	"bloodsucker_v_strong",
	"bloodsucker_v_strong2",
	"sceleton_weak"
	}

local lname
local is_indoor = false

function on_actor_spawn()
	this.surge_db_init()
	lname = level.name()
	is_indoor = isIndoor(lname) 
end

function can_start_surge_now()
  if -- что бы не было одновременно Часа Ужаса и Выброса
    db.actor:has_info( "horror_time_begin" )
    and db.actor:dont_has_info( "horror_fail" )
  then
    if meceniy_utils.check_for_horror_time() then
      return false
    end
  end
	return not (
--[[
	   (lname == "l05_bar" and (has_alife_info("aem_fight_wait") or has_alife_info("bar_arena_fight"))) or
	   (lname == "l06_rostok" and not has_alife_info("bar_rescue_research_done") and not has_alife_info("bar_rescue_research_fail")) or
	   (lname == "l08_yantar" and not has_alife_info("yan_find_scientist_done") and not has_alife_info("yan_scientist_die") and not has_alife_info("yan_scientist_return_to_bunker")) or
]]
	   (lname == "l12u_sarcofag") or 
	   (lname == "l12u_control_monolith") or 
	   (lname == "l12_stancia") or 
	   (lname == "l12_stancia_2") or
	   (lname == "l13_generators_ogse") 
	   )
end
function get_first_surge_wait_time()
	local wait_time_sec = (first_surge_wait_time + math.random( -first_surge_time_disp, first_surge_time_disp ) ) * 3600
	return seconds2ctime(wait_time_sec)
end
function get_surge_wait_time()
  local wait_time_sec = (
    base_surge_wait_time + math.random(
      -surge_wait_time_disp,
      surge_wait_time_disp + math.min( 24, get_blowout_count() )
    )
  ) * 3600
  return seconds2ctime( wait_time_sec )
end
function get_surge_postpone_time()
	return seconds2ctime(surge_postpone_time * 3600)
end

--[[ конфигурация стадий выброса
local surge_db = {
<имя инфопорции стадии> = {
	on_info = { -- действия, выполняемые один раз в момент начала соответствующей стадии
		стандартный набор действий включает в себя:
		Flag2 = 1/0,
		Dead2 = 1/0,
		call# = <имя файла>.<имя функции>, -- # - целое число от 1 и выше
		pp_eff# = {"<имя файла постпроцесса>.ppe", <id>, true/false},
		cam_eff# = {"<имя файла анимации камеры>.anm", <id>, true/false},
		snd# = <путь до файла звука без расширения>, -- звук будет проигран по схеме
		cam_eff_rem# = <id>, -- выключить анимацию камеры
		pp_eff_rem# = <id>, -- выключить эффект постпроцесса
		if_surface = { -- выполнить при условии нахождения на поверхности
			-- стандартный набор действий
		},
		if_underground = { -- если под землёй
			-- стандартный набор действий
		},
		if_not_safe = { -- если на поверхности и не в укрытии
			-- стандартный набор действий
		},
	},
	on_info_deferred = { -- действия, выполняемые в момент начала соответствующей стадии, но не сразу
		-- а при первом апдейте после выдачи соответствуюшей инфопорции
		-- сюда помещаем всякие звуки, постэффекты и т.п. Идея в том, что при пропуске серии стадий
		-- из-за сохранения/загрузки надо выполнить все действия, вошедшие в пропущенные стадии, но 
		-- при этом часть действия типа звуков и постэффектов для пропущенных стадий не выполнять,
		-- поскольку их одновременный проигрыш будет выглядеть нелепо.
		-- Поскольку до первого апдейта секция on_info_deferred не будет парсится, то в первый апдейт 
		-- после загрузки будет проверена только последняя стадия, и действия выполнятся только для неё
		
	-- включает стандартный набор действий, включая ветвление if_surface/if_underground
	},
	on_reinit = { -- действия, выполняемые при загрузке игры если идёт стадия выброса (для восстановления чего-там надо восстанавливать)
	-- стандартный набор действий, включая ветвление if_surface/if_underground
	},
},]]

function set_info_preblow()
	db.actor:give_info_portion("pre_blowout")
end

function set_info_preblow_to_blow()
	db.actor:give_info_portion("pre_blowout2")
end

function set_info_blow()
	db.actor:give_info_portion("blowout")
end

function set_no_net_signal()
	db.actor:give_info_portion("no_net_signal")
end

function set_first_blow()
	if not has_alife_info("first_blowout") then db.actor:give_info_portion("first_blowout") end
end

surge_db = {}
function surge_db_init()
	surge_db.surge_process_stage_01 = {
		on_info = {
			call1 = this.set_info_preblow,  -- инфо предвыброса
			call2 = news_main_new.vubros_msg,  -- новость о выбросе
                        call3 = function()
                          amk.save_variable("blowout",1)
                        end,
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.preblow, -- глухой звук ветра
			},
		},
	}
	surge_db.surge_process_stage_02 = {
		on_info = {
			call1 = this.set_info_preblow_to_blow,
			if_surface = {
				Flag2 = 1,
			}
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.attention_everyone, -- сирена
			}
		},
		on_reinit = {
			if_surface = {Flag2 = 1},
		},
	}
	surge_db.surge_process_stage_03 = {
		on_info = {
			call1 = this.set_info_blow,
                        call2 = function()
                          amk.save_variable("blowout",2)
                        end,
			if_surface = {
				Flag2 = 1,
			},
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.surge_begin, -- глухой звук ветра (ещё раз?)
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1},
		},
	}
	surge_db.surge_process_stage_04 = {-- первые визуальные признаки выброса
		on_info = {
			call1 = amk_anoms.pre_blow_off, -- нужно делать без вариантов незаависимо от подземки
                        call2 = amk_anoms.cleanup_arts,
                        call3 = dsh.blowout_modif_arts,
                        call4 = dsh_rukzak.blowout_modif_arts,
                        call5 = function()
                          db.actor.blowout_outside = true
                        end,
			if_surface = {Flag2 = 1,},
			if_underground = {Flag2 = 0,},
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.surge_sound, -- радиопереговоры с последующими раскатами грома
				pp_eff1 = {"vibros_p.ppe", 1974, false}, -- разовое двоение картинки
				cam_eff1 = {"camera_effects\\earthquake.anm", 1974, true}, -- постоянное раскачивание, как будто качается земля
			},
			if_underground = {
				call1 = soundtrack.play_ambient, -- опять шум ветра
			},
		},
		on_reinit = {
			call1 = amk_anoms.pre_blow_off, -- Поднимаем флаги выброса для локаций
			if_surface = {Flag2 = 1},
			if_underground = {Flag2 = 0},
		},
	}
	surge_db.surge_process_stage_05 = { --3. Проигрываем промежуточные эффекты
		on_info = {
--			call1 = news_main_data.on_disconnect_vbs, -- выдаем сообщение о дисконнекте
--			call2 = this.f_vibros_meter, -- счётчик выбросов - нужен чтобы гарантировано игроку показать пси-выброс, но не слишком рано
--			call3 = this.set_no_net_signal,
			if_surface = {Flag2 = 1,},
			if_underground = {Flag2 = 0,},
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.surge_wave_1, -- хитрое гудение
			},
			if_underground = {
				call1 = soundtrack.play_ambient, -- опять шум ветра
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1},
			if_underground = {Flag2 = 0},
		},
	}
	surge_db.surge_process_stage_06 = {-- 4. Спустя период затишья начинаем выброс
		on_info = {
			if_surface = {Flag2 = 1,},
			if_underground = {Flag2 = 0,},
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.surge_wave_2, -- хитрое гудение
				-- call2 = {xr_sound.set_actor_sound, ""},
				snd1 = [[anomaly\blowout]], -- раскаты грома с сиренами
			},
			call1 = this.play_sounds, -- рандомные звуки: гудение, шум воздуха и пр.
			snd1 = [[ambient\earthquake]], -- низкий глухой шум воздуха с раскатами грома в фоне
			pp_eff1 = {"vibros.ppe", 1974, false},  -- разовое двоение картинки с покраснением, выбелением, выцветанием картинки в конце
			cam_eff1 = {"camera_effects\\earthquake.anm", 1974, true}, -- землетрясение
		},
		on_reinit = {
			if_surface = {Flag2 = 1},
			if_underground = {Flag2 = 0},
		},
	}
	surge_db.surge_process_stage_07 = {-- 5. Начинаем расколбас
		on_info = {
--			call1 = this.deadly_blowout, -- addon by KamikaZze
                        call1 = function()
                          amk.save_variable("blowout",3)
                        end,
			if_surface = {
				call2 = ogse.kill_crow,
				Flag2 = 1, 
				Dead2 = 1,
			},
			if_underground = {
				Flag2 = 0, 
				Dead2 = 0
			},
		},
		on_info_deferred = {
			cam_eff_rem1 = 1974,
			if_not_safe = {
				snd1 = [[actor\pain_3]], -- ой
				cam_eff1 = {"camera_effects\\head_shot.anm", 1975, false}, -- как по голове дали
				pp_eff1 = {"blink.ppe", 2020, false}, -- на пару секунд всё белеет
			},
			if_surface = {
				call1 = soundtrack.surge_wave_3, -- долгое, низкое гудение
				pp_eff1 = {"yantar_underground_psi.ppe", 2010, false}, -- кратковременное раздвоение в глазах
			},
			if_underground = {
				pp_eff1 = {"escape.ppe", 1974, false}, -- короткое покраснение картинки
				call1 = soundtrack.play_ambient, -- шум ветра
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1, Dead2 = 1},
			if_underground = {Flag2 = 0, Dead2 = 0},
		},
	}
	surge_db.surge_process_stage_08 = {
		on_info = {
			if_surface = {
				Flag2 = 1, 
				Dead2 = 1,				
			},
			if_underground = {
				Flag2 = 0, 
				Dead2 = 0				
			},
		},
		on_info_deferred = {
			cam_eff_rem1 = 1974,
			if_surface = {
				call1 = soundtrack.surge_wave_4, -- опять гудение
			},
			if_underground = {
				rnd = {
					{
						call1 = soundtrack.rock_sound, -- камешки сыпятся
						pp_eff1 = {"yantar_underground_psi.ppe", 1974, false},
					},
					{
						snd1 = [[ambient\earthquake]], -- отдалённый грохот камней или обвал
						pp_eff1 = {"total_recall.ppe", 1974, false}, -- сильное кратковременное двоение
					},
					{
						snd1 = [[ambient\earthquake]],
						pp_eff1 = {"agr_u_fade.ppe", 1974, false}, -- полное плавное почернение, потом плавный возврат
						pp_eff2 = {"total_recall.ppe", 1986, false},
					},
					{
						-- тут тишина
					},
				},
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1, Dead2 = 1},
			if_underground = {Flag2 = 0, Dead2 = 0},
		},
	}
	surge_db.surge_process_stage_09 = {
		on_info = {
			if_surface = {
				Flag2 = 1, 
				Dead2 = 1,				
			},
			if_underground = {
				Flag2 = 0, 
				Dead2 = 0				
			},
		},
		on_info_deferred = {
			cam_eff_rem1 = 1974,
			if_surface = {
				call1 = soundtrack.surge_rumble, -- шум ветра с отдалёнными раскатами грома
			},
			if_underground = {
				rnd = {
					{
						call1 = soundtrack.rock_sound, -- камешки сыпятся
						pp_eff1 = {"yantar_underground_psi.ppe", 1974, false}, -- лёгкое короткое двоение с расплыванием
					},
					{
						snd1 = [[ambient\earthquake]],
						pp_eff1 = {"total_recall.ppe", 1974, false},
					},
					{
						snd1 = [[ambient\earthquake]],
						pp_eff1 = {"agr_u_fade.ppe", 1974, false},
						pp_eff2 = {"total_recall.ppe", 1986, false},
					},
					{
						-- тут тишина
					},
				},
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1, Dead2 = 1},
			if_underground = {Flag2 = 0, Dead2 = 0},
		},
	}
	surge_db.surge_process_stage_10 = surge_db.surge_process_stage_09
	surge_db.surge_process_stage_11 = surge_db.surge_process_stage_09
	surge_db.surge_process_stage_12 = surge_db.surge_process_stage_09
	surge_db.surge_process_stage_13 = {-- 6. Выброс близится к концу
		on_info = {
                        call1 = function()
                          amk.save_variable("blowout",4)
                        end,
			if_surface = {
				Flag2 = 1, 
				Dead2 = 1,				
			},
			if_underground = {
				Flag2 = 0, 
				Dead2 = 0,				
			},
		},
		on_info_deferred = {
			if_surface = {
				call1 = soundtrack.surge_outro, -- опять шум воздуха/ветра
			},
			if_underground = {
				call1 = soundtrack.play_ambient,
			},
		},
		on_reinit = {
			if_surface = {Flag2 = 1, Dead2 = 1},
			if_underground = {Flag2 = 0, Dead2 = 0},
		},
	}
	surge_db.surge_process_stage_14 = {-- 7. Завершаем выброс, устанавливаем время следующего
		on_info = {
			if_surface = {
				Flag2 = 0, 
				Dead2 = 0,					
			},
			if_underground = {
				Flag2 = 0, 
				Dead2 = 0,					
			},
			call1 = this.set_first_blow,
			call2 = this.on_surge_end, --  сюда скинул всё, что неудобно вызывать в простой форме
			Dead2 = 0, 
			Flag2 = 0,
		},
		on_info_deferred = {
			if_surface = {
				pp_eff1 = {"teleport.ppe", 2009, false}, -- всё полностью белеет, потом обратно
			},
			if_underground = {
				pp_eff1 = {"escape.ppe", 2009, false},
			},
			if_not_safe = {
				cam_eff1 = {"camera_effects\\shell_shock.anm", 1974, false}, -- короткая, затухающая встряска
				snd1 = [[actor\breath_1]], -- дыхота
			},
			pp_eff1 = {"yantar_underground_psi.ppe", 2010, false},
			snd1 = [[ambient\earthquake]],
		},
	}
	surge_db.surge_process_stage_15 = {-- 6. Выброс близится к концу
		on_info = {
			if_surface = {
--				call1 = ogse.spawn_crow,
			},
			call1 = this.surge_final,
		},
		on_info_deferred = {
		},
	}	
end

function on_surge_end()
--[[
	local blowout_count = ogse.load_variable("blowout_count",0)
	blowout_count = blowout_count + 1
	ogse.save_variable("blowout_count",blowout_count)

	ogse_anomaly.add_anom(level.name(), true)
	ogse_anomaly.need_disable_anomaly = true
	if psyzones_flag == 2 then
		ogsm_psyzones.psy_blow_flags()
		ogsm_psyzones.spawn_psy()
	end
	local add_spawn = ogse_additional_spawn.additional_spawn()
	
	if add_spawn.additional_spawn_accept == 1 then
		die_actor_counter = 0
		add_spawn:spawn_creatures() -- вызов функции
	end
	add_spawn = nil -- чистим неиспользуемое
	
	this.horror_and_arts()
	ogsm_respawn.level_spawn()
	move_mgr.invalidate_pp_accessibility()
]]
	amk_anoms.after_blow_on()
	amk.del_variable("blowout")
	db.actor:disable_info_portion("blowout")
	db.actor:disable_info_portion("pre_blowout2")
--	if news_main_data then news_main_data.on_connect_vbs() end -- выдаем сообщение о коннекте
	if news_main_new then news_main_new.vubros_out_msg() end  -- сообщение о завершении выброса
--	db.actor:give_info_portion("net_signal") -- связь восстановлена	
        if game_options.zombie_team == 1 then
            tag_spb.zombie_team()
        end 
	if db.actor.blowout_outside then
		archievements.acv_count_event("acv_blow", 5, "Выброшенный")
		db.actor.blowout_outside = nil
	end
	dsh.spawn_all_respawners()
	amk.start_timer("autosave_blowout", 10, "") -- autosave
        ogse.save_var(
          script_name() .. ".blowout_count",
          ogse.load_var( script_name() .. ".blowout_count", 0 ) + 1,
          "u32"
        )
--[[
	ogse_yan_random_quest.reinit_item_list() -- получаем новый список предметов у Сахарова (Mixser)
]]	
end

function surge_final()
	db.actor:disable_info_portion("pre_blowout")
	db.actor:disable_info_portion("surge_process_stage_1")
	db.actor:disable_info_portion("surge_process_stage_2")
	db.actor:disable_info_portion("surge_process_stage_3")
	db.actor:disable_info_portion("surge_process_stage_4")
	db.actor:disable_info_portion("surge_process_stage_5")
	db.actor:disable_info_portion("surge_process_stage_6")
	db.actor:disable_info_portion("surge_process_stage_7")
	db.actor:disable_info_portion("surge_process_stage_8")
	db.actor:disable_info_portion("surge_process_stage_9")
	db.actor:disable_info_portion("surge_process_stage_10")
	db.actor:disable_info_portion("surge_process_stage_11")
	db.actor:disable_info_portion("surge_process_stage_12")
	db.actor:disable_info_portion("surge_process_stage_13")
	db.actor:disable_info_portion("surge_process_stage_14")
	db.actor:disable_info_portion("surge_process_stage_15")
	ogse_weather_mgr.get_weather_mgr():prepare_new_surge() -- тут вставляем перезапуск выброса в погодном менеджере		
end

--------------------------------- Парсер единичного действия ---------------------------------------
function parse_and_process_action_item(key, item)
	ASSERT(type(key) == "string", "[ogse_surge_mgr.parse_and_process_action_item] action key is not a string, '%s'", type(key))
	if     key:sub(1, 4) == "call" then
		ASSERT(type(item) == "function", "[ogse_surge_mgr.parse_and_process_action_item] cannot execute function for the key '%s'", key)
		item()
	elseif key:sub(1, 11) == "cam_eff_rem" then
		-- TODO: проверить, что эффект работает
		level.remove_cam_effector(item)
	elseif key:sub(1, 10) == "pp_eff_rem" then
		-- TODO: проверить, что эффект работает		
		level.remove_pp_effector(item)
	elseif key:sub(1, 6) == "pp_eff" then
		-- TODO: проверить, что эффект работает
		--{"<effect path>", 1974, false},
		level.add_pp_effector(item[1],item[2],item[3])
	elseif key:sub(1, 7) == "cam_eff" then
		-- TODO: проверить, что эффект работает
		--{"<effect path>", 1975, false},
		level.add_cam_effector(item[1],item[2],item[3],"")
	elseif key:sub(1, 3) == "snd" then
		local snd_obj = xr_sound.get_safe_sound_object(item)
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
	elseif key == "Dead2" then
		db.Dead2 = item
	elseif key == "Flag2" then
		db.Flag2 = item
	else
		abort("[ogse_surge_mgr.parse_and_process_action_item] unknown action '%s'", key)
	end
end
--------------------------- Парсер описателя стадии выброса с действиями ---------------------------
local function parse_and_process_surge_stage(stage_info)
	for key, item in pairs(stage_info) do
		if key == "if_underground" then
			if is_indoor then
				parse_and_process_surge_stage(item)
			end
		elseif key == "if_surface" then
			if not is_indoor then
				parse_and_process_surge_stage(item)
			end
		elseif key == "if_not_safe" then
		  if not amk_mod.outfit_hideout() then -- защита от выброса броником
			if not ogse_hideouts.npc_inside_safe_zone(db.actor) then
				parse_and_process_surge_stage(item)
			end
                  end
		elseif key == "rnd" then
			local stage = item
			stage = item[math.random(1,#item)]
			parse_and_process_surge_stage(stage)
		else
			parse_and_process_action_item(key, item) -- TODO: проверить алгоритм, мог накосяяить
		end
	end
end

--==================================================================================================
--============================= обработчики системных событий ======================================
--==================================================================================================
-- 5			"surge_process_stage_01"	ogse_surge_1	новость о выбросе, смена погоды
-- 55			"surge_process_stage_02"	ogse_surge_2	сирена выброса
-- 15			"surge_process_stage_03"	ogse_surge_3	реально начало, звуки выброса
-- 70			"surge_process_stage_04"	ogse_surge_4	первые визуальные признаки выброса, флаги смены аномалий, трясучка
-- 23			"surge_process_stage_05"	ogse_surge_6	выдаем сообщение о дисконнекте, звук волны 1
-- 11			"surge_process_stage_06"	ogse_surge_7	волна 2, трясучка, звуки угрожающие
-- 6			"surge_process_stage_07"	ogse_surge_8	удар по актору, волна 3, падение ворон, волна радиации
-- 14			"surge_process_stage_08"	ogse_surge_11	волна 4
-- 20			"surge_process_stage_09"	ogse_surge_12	грохот
-- 20			"surge_process_stage_10"	ogse_surge_13	аналогично 9
-- 20			"surge_process_stage_11"	ogse_surge_15	аналогично 9
-- 15			"surge_process_stage_12"	ogse_surge_17	аналогично 9
-- 30			"surge_process_stage_13"	ogse_surge_19	звуки завершения
-- 30			"surge_process_stage_14"	ogse_surge_20	завершение выброса
-- 10			"surge_process_stage_15"	ogse_surge_21	финализация, вороны

local deferred_actions = nil -- запрос на выполнение отложенных действий
-- делаем что-то для обновления текущего состояния
function on_actor_update()
	if deferred_actions then
		local info_action = deferred_actions.on_info_deferred
		if info_action then
			parse_and_process_surge_stage(info_action)
		end
		deferred_actions = nil
	end
	if db.actor:has_info("blowout") then
		if ogse_hideouts.npc_inside_safe_zone(db.actor)
		or amk_mod.outfit_hideout()
		then
			db.FlagEsc = 1
		else	
			db.FlagEsc = 0
		end	
		if db.Dead2 == 1 and db.FlagEsc == 0 then
			g_R_Vibros:Run()
--			hit_actor()
			play_sounds()
			level.add_pp_effector("dead_zone.ppe", 1003, true)
			-- level.add_pp_effector("radiation.ppe", 1003, true)
			level.set_pp_effector_factor(1003, 0.5)
		end
		if db.FlagEsc == 1 then
			g_R_Vibros:Stop()
		end
	else
		if db.FlagEsc == 1 then
			db.FlagEsc = 0
			db.Dead2 = 0
			g_R_Vibros:Stop()
		end
	end
end
-- выполняем реинициализацию фазы выброса при перезагрузке
function on_first_update() -- выполняем восстановление временных эффектов, флагов и т.п.
	if db.actor:has_info("pre_blowout") then
		-- ищем текущую стадию выброса
		for stage_infoportion, stage_actions in pairs(surge_db) do
			-- если сейчас активна стадия выброса
			if db.actor:has_info(stage_infoportion) then
				local info_action = stage_actions.on_reinit
				if info_action then
					parse_and_process_surge_stage(info_action)
				end
				deferred_actions = stage_actions		
				break
			end
		end
	end
end
-- выполняем действия, которые должны выполниться строго один раз в момент наступления фазы выброса
function on_get_info(npc, info_id)
	
	local action_item = surge_db[info_id]
	if action_item then
		surge_log("surge stage: %s", tostring(info_id))
		deferred_actions = action_item -- запрашиваем выполнение отложенных действий
		local info_action = action_item.on_info
		if info_action then
			log1("!!SURGE_DEBUG: info["..tostring(info_id).."]")
			parse_and_process_surge_stage(info_action)
		end
	end
end

-- Служебные функции выброса --

local monster_kill_exclusion = {
	[clsid.snork_s]       = true,
	[clsid.bloodsucker_s] = true,
	[clsid.burer_s]       = true,
	[clsid.gigant_s]      = true,
	[clsid.chimera_s]     = true,
	[clsid.controller_s]  = true,
	[clsid.zombie_s]      = true,
}
-- Очистка гулагов монстров после выброса
function kill_monsters(gulag1)
	if not gulag1 then return end
	
	for k, v in pairs(gulag1.Object) do 	
		if level.object_by_id(k) ~= nil then
			obj = level.object_by_id(k)
			if obj:is_monster() and not monster_kill_exclusion[get_clsid(obj)] then
				obj:kill(obj)
			end
		end	
	end
end

local actor_was_hit = false

-- Deadly Blowout by KamikaZze - Нанесение актору удара волной в смертельной стадии выброса, если он не спрятался
function deadly_blowout()
	if not actor_was_hit and not is_indoor and not ogse_hideouts.npc_inside_safe_zone(db.actor) then
		-- Hit by explosion
		local blow = hit()
		blow.direction = vector():set(0,0,0)
		blow.impulse = 0
		blow.draftsman = db.actor
		blow.power = ogse.level_blow_damage(lname)*ogse.armor_class(db.actor)
		blow.type = hit.explosion
		db.actor:hit(blow)
		
		level.add_cam_effector("camera_effects\\fusker.anm",959,false,"")
		
		local active_item = db.actor:active_item()
		if active_item and active_item:section()~= "bolt" and active_item:section()~= "wpn_knife" then
			db.actor:drop_item(active_item)
		end		
		
		local protection = db.actor:item_in_slot(6)
		if protection then
			local current_cond = protection:condition()
			local damage = 0.2*ogse.armor_class(db.actor)
			local new_cond = current_cond - damage
			if new_cond > 0 then
				protection:set_condition(new_cond)
			else protection:set_condition(0.1) end
		end		
		-- Zombied chance
		local zmb_probability = ogse.level_blow_damage(lname)*10
		local rnd = math.random()
		
		if zmb_probability > rnd then
			dialogs.actor_set_zombied(actor, npc)		 
			level.add_pp_effector("deadcity_wake.ppe", 2008, false)
		end
		actor_was_hit = true
	end
end

local surge_hit_db = {
	l01_escape     = { power = 0.001,  type = hit.radiation},
	l02_garbage    = { power = 0.0013, type = hit.radiation},
	l03_agroprom   = { power = 0.0018, type = hit.radiation},
	l04_darkvalley = { power = 0.0018, type = hit.radiation},
	l05_bar        = { power = 0.0023, type = hit.radiation},
	l06_rostok     = { power = 0.0023, type = hit.radiation},
	l08_yantar     = {{power = 0.003,  type = hit.radiation}, {power = 0.0001, type = hit.shock}, },
	l07_military   = {{power = 0.005,  type = hit.radiation}, {power = 0.0005, type = hit.shock}, },
	l10_radar      = {{power = 0.008,  type = hit.radiation}, {power = 0.0007, type = hit.shock}, },
	l11_pripyat    = {{power = 0.01,   type = hit.radiation}, {power = 0.001,  type = hit.shock}, },
}
-- Нанесение хита актору в смертельной стадии выброса
function hit_actor()
	local hit_data = surge_hit_db[lname]
	if hit_data then
		local psy_hit = hit()
		psy_hit.direction = vector():set(0,0,0)
		psy_hit.impulse = 0
		psy_hit.draftsman = db.actor
		--
		if hit_data.power and hit_data.type then
			psy_hit.power = hit_data.power
			psy_hit.type = hit_data.type
			db.actor:hit(psy_hit)
		else
			for _,hd in ipairs(hit_data) do
				psy_hit.power = hd.power
				psy_hit.type = hd.type
				db.actor:hit(psy_hit)
			end
		end
	end
end

-- Обобщенная процедура спавна артефактов
function proceed_art_spawn(section, count)
	for ind = 1, count do
		local pos, new_lv, new_gv = ogse_anomaly.anomaly_position_choice(lname, false)
		if pos and new_lv and new_gv then
			alife():create(section, pos, new_lv, new_gv)
		end
	end
end

-- Спавн фантомов
function play_phantoms()
	if math.random() < 0.5 then
		if phantom_manager:phantom_count() < 5 then
			local yaw = math.pi*2.0*math.random()
			local radius = 30*(math.random()/2.0+0.5)
			local height = 2.5*math.random()
			local a_pos = db.actor:position()
			local pos = vector():set(math.sin(yaw)*radius+a_pos.x,a_pos.y+height,math.cos(yaw)*radius+a_pos.z)
			phantom_manager.spawn_phantom(pos)
		end
	end
end

-- Проигрыш странных звуков
function play_sounds()

	sound_obj_right.volume = 0.5
	sound_obj_left.volume = 0.5

	if not sound_obj_left:playing() then 
		local i=math.random(1,4)
		if i==1 then 
			sound_obj_left = sound_object([[ambient\rnd_outdoor\rnd_dark4]])
		elseif i==2 then
			sound_obj_left = sound_object([[ambient\rnd_outdoor\rnd_moan1]])
		elseif i==3 then
			sound_obj_left = sound_object([[ambient\rnd_outdoor\rnd_moan2]])
		elseif i==4 then
			sound_obj_left = sound_object([[ambient\rnd_outdoor\rnd_dark6]])
		end
		if sound_obj_left then
			sound_obj_left:play_at_pos (db.actor, vector():set(1, 0, 1), 0, sound_object.s2d) 
		end
	end

	if not sound_obj_right:playing() then 
		local j=math.random(1,4)
		if j==1 then 
			sound_obj_right = sound_object([[ambient\rnd_outdoor\rnd_dark4]])
		elseif j==2 then
			sound_obj_right = sound_object([[ambient\rnd_outdoor\rnd_moan1]])
		elseif j==3 then
			sound_obj_right = sound_object([[ambient\rnd_outdoor\rnd_moan2]])
		elseif j==4 then
			sound_obj_right = sound_object([[ambient\rnd_outdoor\rnd_dark6]])
		end
		if sound_obj_right then
			sound_obj_right:play_at_pos (db.actor, vector():set(-1, 0, 1), 0, sound_object.s2d) 
		end
	end

end

local horror_objects_db = {
	l01_escape = {
		horror = {prob = 0.25, use_surge_count = true, 
			spawn_items = {["phantom_zombi_3"] = 2,},
		},
		spawn = {prob = 0.1,
			items = {["af_medusa"] = 1, ["af_vyvert"] = 1, ["af_blood"] = 1, ["af_electra_sparkler"] = 1,}
		},
	},
	l02_garbage = {
		horror = {prob = 0.3, use_surge_count = true, 
			spawn_items = escape_phantom_types,
		},
		spawn = {prob = 0.1,
			items = { ["af_cristall_flower"] = 1, ["af_gravi"] = 1, ["af_rusty_thorn"] = 1,},
		},
	},
	l03_agroprom = {
		horror = {prob = 0.3, use_surge_count = true, 
			spawn_items = escape_phantom_types,
		},
		spawn = {prob = 0.1,
			items = {["af_cristall_flower"] = 1, ["af_gravi"] = 1, ["af_rusty_thorn"] = 1, ["af_mincer_meat"] = 1, },
		},
	},
	l04_darkvalley = {
		horror = {prob = 0.4, use_surge_count = true, 
			spawn_items = escape_phantom_types,
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_glassbeads"] = 1, ["af_electra_flash"] = 1, ["af_fuzz_kolobok"] = 1, ["af_fireball"] = 1, },
		},
	},
	l05_bar = {
		spawn = {prob = 0.1,
			items = {["af_dummy_pellicle"] = 1, ["af_ameba_slime"] = 1, ["af_soul"] = 1, ["af_rusty_kristall"] = 1, },
		},
	},
	l06_rostok = {
		horror = {prob = 0.6, use_surge_count = false,
			spawn_items = {["phantom_snork_1"] = 2},
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_pellicle"] = 1, ["af_ameba_slime"] = 1, ["af_soul"] = 1, ["af_rusty_kristall"] = 1, },
		},
	},
	l07_military = {
		horror = {prob = 0.6, use_surge_count = false,
			spawn_items = military_phantom_types,
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_battery"] = 1, ["af_rusty_sea-urchin"] = 1, ["af_electra_moonlight"] = 1, ["af_ameba_slug"] = 1, ["af_electra_sparkler"] = 1, },
		},
	},
	l08_yantar = {
		horror = {prob = 0.6, use_surge_count = false,
			spawn_items = {["phantom_snork_1"] = 1},
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_battery"] = 1, ["af_dummy_dummy"] = 1, ["af_night_star"] = 1, ["af_gold_fish"] = 1, },
		},
	},
	l10_radar = {
		horror = {prob = 0.7, use_surge_count = false,
			spawn_items = military_phantom_types,
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_spring"] = 1, ["af_rusty_sea-urchin"] = 1, ["af_electra_moonlight"] = 1, ["af_ameba_mica"] = 1,	},
		},
	},
	l11_pripyat = {
		horror = {prob = 0.8, use_surge_count = false,
			spawn_items = military_phantom_types,
		},
		spawn = {prob = 0.1,
			items = {["af_dummy_spring"] = 1, ["af_night_star"] = 1, ["af_dummy_glassbeads"] = 1, ["af_fuzz_kolobok"] = 1, },
		},
	},
}

function process_spawn_items(items)

	local num = 1
	local sect = nil
	for k,v in pairs(items) do
		
		if type(k) == "string" then -- прямое указание секции
			sect = k
			num = v
		elseif type(k) == "number" then -- случайный выбор из таблицы
			sect = items[math.random(#items)]
			num = 1
		else
			abort("ogse_surge_mgr.process_spawn_items "..tostring(k).." type "..type(k))
		end
		if sect then
			proceed_art_spawn(sect, num)
		end
	end
end

-- Вызов спавна артефактов и хоррор-тайма
function horror_and_arts()
	---- обнуление переменной 
	
	lname = level.name()
	actor_was_hit = false -- TODO: перенести это в другое место
	local actions = horror_objects_db[lname]
	
	if actions then
		local blowout_count = ogse.load_variable("blowout_count",0)
		if horror_flag == 1 and actions.horror and ((math.random() < actions.horror.prob) or (actions.horror.use_surge_count and blowout_count ==  horror_time_proshow)) then
			horror_time.horror_begin()
			process_spawn_items(actions.horror.spawn_items)
		end
		if actions.spawn and math.random() < actions.spawn.prob then
			process_spawn_items(actions.spawn.items)
		end
	end
end


class "R_Vibros"
function R_Vibros:__init()
	self.work = 0
end

g_R_Vibros = R_Vibros()

function R_Vibros:construct()
end

function R_Vibros:Run()
	if self.work == 0 then
		xr_sound.set_actor_sound("level_border_detector")
		xr_sound.set_actor_sound_factor(0.01)
		level.add_cam_effector("camera_effects\\fatigue.anm", 2004, true, "")
		level.add_pp_effector("yantar_underground_psi.ppe", 299, true)
		level.set_pp_effector_factor(299, 1.0)
		self.work = 1
	end
end

function R_Vibros:Stop()
	if self.work == 1 then
		level.remove_pp_effector(1003)
		level.remove_cam_effector(2004)
		level.remove_pp_effector(299)
		xr_sound.set_actor_sound("")
		self.work = 0
	end
end


 -- счётчик выбросов
function f_vibros_meter()
	if has_alife_info("vibros_meter_done") then return end
	local vibros_meter_limit = 10 -- предел работы счётчика
	local vibros_meter = tonumber(ogse.load_variable("vmr",0))
	vibros_meter = vibros_meter + 1
	if vibros_meter < vibros_meter_limit then
		ogse.del_variable("vmr")
		ogse.save_variable("vmr",vibros_meter) -- счётчик выбросов
	else
		ogse.del_variable("vmr")
		db.actor:give_info_portion("vibros_meter_done") -- завершаем работу счетчика
	end
end


function get_blowout_count()
  return ogse.load_var( script_name() .. ".blowout_count", 0 )
end
