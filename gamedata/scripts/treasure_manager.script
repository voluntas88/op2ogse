-- -*- mode: lua; coding: windows-1251-dos -*-
-- solid_list основан на Linspiro Addon v1.1


local rare_list = {

 novice_section = {
 "wpn_toz34",
 "wpn_ak74",
 "wpn_mp5_m1",
 "wpn_colt_m1",
 "wpn_mp5_m2",
 "wpn_walther_m1",
 "wpn_fort_m1",
 "scientific_outfit",
 "stalker_outfit_v3",
 "specops_outfit",
 "dolg_gaz_outfit_m1",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "mutant_flesh_eye",		
 "mutant_boar_leg",		
 "mutant_dog_tail",		  			
 "mutant_zombie_hand",		
 "mutant_face_tushkano",		
 "mutant_tail_cat",				   
 "mutant_spleen_rat",
 "mutant_plague_hand",
 "af_medusa",
 "af_vyvert",
 "af_blood",
 "af_electra_sparkler",
 "af_rusty_thorn",
 "af_ameba_slime",
 "af_drops",      	
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_electra_moonlight",
 "af_gravi",
 "af_cristall_flower",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 "medkit",
 "outfit_soldier_m1",
 "neytral_novice_outfit_m1",
 "neytral_novice_outfit_new",
 "neytral_novice_outfit_cam_1",
 "neytral_novice_outfit_cam_2",
 "neytral_novice_outfit_cam_3",
 "bandit_outfit",
 "bandit_outfit_blue",
 "bandit_outfit_red",
 "mushroom",
 "fake_wpn_knife",
 "sigaret",
 "ammo_9x19_pbp",
 "ammo_11.43x23_hydro",
 "ammo_zhekan_izomorf",
 "mutant_tushkano_cocoon",
 "mutant_dog_cocoon",
 "mutant_psevdodog_cocoon",
 "mutant_flesh_cocoon",
 "mutant_cat_cocoon",
 "mutant_boar_cocoon",
  },

 experienced_section = {
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_og-7b",
 "ammo_5.45x39_izomorf",
 "ammo_7.62x39_ap",
 "ammo_7.62x51box",
 "mutant_zombie_hand",
 "mutant_snork_leg",				
 "mutant_poltergeist_glas",				
 "mutant_fracture_hand", 
 "mutant_boar_leg",
 "mutant_carlic_hand",
 "part_tarakan_strong",
 "mutant_vypolzen_hrebet",
 "wpn_m16a2_sk1",
 "wpn_sg552_sk1",
 "wpn_wincheaster1300",
 "wpn_m4",
 "wpn_ppsh41_sk2",
 "wpn_abakan_m1",
 "wpn_fort_m1",
 "wpn_winchester_m1",
 "wpn_l85_m1",
 "wpn_l85_m2",
 "wpn_beretta_m1",
 "military_outfit",
 "svoboda_heavy_outfit",
 "dolg_scientific_outfit",
 "freedom_scientific_outfit",
 "merc_scientific_outfit",
 "monolit_scientific_outfit",
 "nebo_scientific_outfit",
 "outfit_dolg_m1",
 "outfit_killer_m1",
 "af_fuzz_kolobok",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_babka_1",
 "af_spirit_1",
 "medkit_army",
 "mutant_zombie_cocoon",
 "mutant_snork_cocoon",
 "mutant_poltergeist_cocoon",
 "amk_kanistra",
 },

 veteran_section = {
 "af_dummy_dummy",
 "af_fuzz_kolobok",
 "af_spirit_1",        
 "af_spirit_2",       
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_pudd_2",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "af_armor_2",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_eye_voron",
 "ammo_og-7b",
 "grenade_flash",
 "ammo_vog-25p",	
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_9x39_izomorf",
 "ammo_minigun",
 "ammo_5.56x45_ap",
 "ammo_20x85",
 "ammo_7.62x51_ap",
 "ammo_gauss",
 "nebo_exo_outfit",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",
 "mutant_zombie_hand",	
 "mutant_hand_kontroler",			
 "mutant_psevdogigant_hand",			
 "mutant_chimera_kogot",
 "mutant_spider_gland",
 "mutant_rotan_heart",
 "mutant_zanoza_leg",
 "wpn_spas12",
 "wpn_m1891_30_scope",
 "wpn_groza",
 "medkit_scientic",
 "mutant_krovosos_cocoon",
 "mutant_burer_cocoon",
 "mutant_chimera_cocoon",
 "amk_ballon",
 },

master_section = {
 "wpn_spas12",
 "wpn_groza",
 "wpn_val_m1",
 "wpn_protecta",	
 "wpn_mp5k_pdw57",
 "wpn_mp5k_pdw_tt",
 "wpn_g3_otdaca_ves",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",		
 "mutant_hand_kontroler",				
 "mutant_psevdogigant_hand",					
 "mutant_chimera_kogot",
 "mutant_deathclaw_antler",
 "mutant_raptor_kogot",
 "mutant_plague_hand",
 "mozg",
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_og-7b",
 "grenade_rgd5",
 "ammo_7.62x54_izomorf",
 "ammo_7.62x39_k",
 "ammo_7.62x54r",
 "ammo_357_ap_mag",
 "ammo_12.7x108r",
 "ammo_balon",
 "ammo_12.7x108",
 "ammo_super_gauss",
 "svoboda_exoskeleton",
 "nebo_exo_outfit",
 "exo_bandit_outfit",
 "voen_exo_outfit",
 "exo_scientist_outfit",
 "exo_outfit",
 "dolg_black_exoskeleton",
 "killer_green_exoskeleton",
 "seva_scient_outfit",
 "af_simbion",        
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_babka_3",
 "af_dik_2",
 "af_kol_2",
 "af_kol_3",
 "af_armor_2", 
 "af_armor_3",
 "suvorotka",
 "medkit_scientic",
 "mutant_gigant_cocoon",
 "mutant_controller_cocoon",
 }
}

local solid_list = {
 novice_section = {
 --Артефакты--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --Аммуниция--
 "grenade_rgd5",
 "ammo_12x70_buck",     
 "ammo_9x19_fmj",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_9x18_fmj",
 --Оружие--
 "wpn_addon_silencer",
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pb",
 "wpn_pm",
 --Прочее--
 "bread",
 "bandage",
 "kolbasa",
 "medkit",
 "vodka",
 "sigaret",
 "conserva"
 },

experienced_section = {
--Артефакты--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --Аммуниция--
 "grenade_rgd5",
 "grenade_gd-05",
 "grenade_flash",
 "grenade_f1",     
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_5.45x39_fmj",
 "ammo_11.43x23_fmj",
 "ammo_5.56x45_ss190",
 --Пушки--
 "wpn_addon_scope",
 "wpn_mp5",
 "wpn_ak74u",
 "wpn_ak74u_m1",
 "wpn_walther",
 --Прочее--
 "mutant_dog_tail",
 "mutant_boar_leg",
 "kolbasa",
 "medkit",
 "antirad",
 "energy_drink",
 "conserva"
 },

 veteran_section = {
 --Артефакты--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_cristall",
 --Аммуниция--
 "grenade_f1",
 "ammo_vog-25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_pab9",
 "ammo_5.56x45_ss190",
 "ammo_12x76_zhekan",
 --Пушки--
 "wpn_addon_scope_susat",
 "wpn_addon_grenade_launcher",
 "wpn_beretta",
 "wpn_sig550",
 "wpn_toz34",
 "wpn_abakan_m2",
 "wpn_desert_eagle",
 --Прочее--
 "mutant_psevdodog_tail",
 "mutant_snork_leg",
 "medkit_army",
 "antirad"
 },

 master_section = {
 --Артефакты--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --Аммуниция--
 "ammo_m209",
 "ammo_vog-25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 "ammo_7.62x54_7h1",
 --Пушки--
 "wpn_addon_grenade_launcher_m203",
 "wpn_colt1911",
 "wpn_spas12",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza",
 "wpn_groza_m1",
 --Прочее--
 "mutant_krovosos_jaw",
 "mutant_burer_hand",
 "medkit_army",
 "medkit_scientic"
 }
}

local treasure_manager = nil
local n_rank 

function parse_spawns(line)
	if line == nil then
		return {}
	end

	--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
	local t = se_respawn.parse_names(line)
	local n = table.getn(t)
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		table.insert(ret_table, spawn)
	end
	return ret_table
end


class "CTreasure"
function CTreasure:__init()
  --' На конструкторе вычитываем LTX и создаем заготовки квестов.
  self.ini = sys_ini --ini_file("misc\\treasure_manager.ltx")

  --' Итерируемся по всем настройкам фраз
  ASSERT(
    self.ini:section_exist( "treasure_manager.list" ),
    "There is no section [list] in treasure_manager.ltx"
  )

  local n = self.ini:line_count( "treasure_manager.list" )
  local result, id, value = 0, "", ""

  --' начальная установка
  self.treasure_info = {}
  for i = 0, n - 1 do
    result, id, value = self.ini:r_line( "treasure_manager.list", i, "", "" )
    local info    = {}
    local id_sect = "treasure_manager." .. id
    info.target = utils.cfg_get_number( self.ini, id_sect, "target", nil, true )
    info.named  = utils.cfg_get_bool( self.ini, id_sect, "named", nil, false )
    info.name   = utils.cfg_get_string( self.ini, id_sect, "name", nil, true, "" )
    --' Отметим тайник как новый
    info.active = false
    info.done   = false
    self.treasure_info[ id ] = info
  end

  --' Вспомогательные таблицы для облегчения поиска
  self.treasure_by_target = {}
  local cnt = 0
  for k, v in pairs( self.treasure_info ) do
    self.treasure_by_target[ v.target ] = k
    cnt = cnt + 1
  end
  ASSERT( n == cnt, "wrong num of loaded items: %s ~= %s", n, cnt )
end


--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use( npc )
  --lootmoney start
  if npc and db.actor then
    lootmoney.lootmoney( npc )
  end
  --lootmoney end
  local rarets

  if npc then
    n_rank = npc:character_rank()
  else
    n_rank = 0
  end

  -- если выбран редкий тип тайников, то снизим вероятность его выпадения
  if amk.load_variable( "option_treasure", 0 ) == 2 then
    rarets = 99
  else
    rarets = 97
  end
  if amk.is_debug then
    rarets=0
  end

  if math.random( 100 ) < rarets then 
    return
  end

  --' Нужно рандомно выбрать один из тайников.
  local avail  = {}
  local tr_sum = 0
  local treasure_prob

  for k, v in pairs( self.treasure_info ) do
    if v.done == false and v.active == false then
      treasure_prob = xr_logic.pick_section_from_condlist(
        db.actor, npc,
        xr_logic.parse_condlist(
          db.actor, "treasure_manager", "condlist",
          utils.cfg_get_string(
            self.ini, "treasure_manager." .. k, "condlist", nil, true, ""
          )
        )
      )
      if treasure_prob == "" or treasure_prob == nil then
        treasure_prob = 0
      end
      if tonumber( treasure_prob ) >= 0 and v.active == false then
        if tonumber( treasure_prob ) == 100 then
          self:give_treasure( k )
        else
          table.insert( avail, { k = k, prob = treasure_prob } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end

  if tr_sum == 0 or
    math.random( 100 ) < 50
  then
    return
  end

  local tr_w = math.random( tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      --' Выдать тайник
      self:give_treasure( v.k )
      break
    end
  end
end


--' Сохранение
function CTreasure:check()
	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do
		--' Выдать тайник
		self:give_treasure(k)
	end
end
--' Напоминания об активных тайниках на текущей территории
function CTreasure:remind()
	local obj
	local have = false
	local sms = "%c[255,160,160,160]Тайники:\\n"
	
	for k,v in pairs(self.treasure_info) do
		if v.active then
			obj = alife():story_object(v.target)
			if obj and game_graph():vertex(obj.m_game_vertex_id):level_id() == alife():level_id() then
				sms = sms.."%c[170,200,200,200]"..game.translate_string(v.name).."\\n"
				have = true
			end
		end
	end
	
	if have then
		local task_texture, task_rect = get_texture_info("ui_iconsTotal_abstract5")
		db.actor:give_game_news(sms, task_texture, task_rect, 0, 30000)
	end
end


--' Выдача тайника
function CTreasure:give_treasure( k )
  local v = self.treasure_info[ k ]
  local obj = alife():story_object( v.target )
  if obj then
    ASSERT(
      obj:clsid() == clsid.inventory_box,
      "Story object [%s] is not an inventory box", v.target
    )
    news_manager.send_treasure( v.name )

    --' Пометить на карте
    local text = "%c[255,238,155,23]" .. game.translate_string( v.name ) .. "\\n" .. "%c[default]" .. game.translate_string( utils.cfg_get_string( self.ini, "treasure_manager." .. k, "description", nil, true, "" ) )
    dsh.map_add_treasure( obj.id, "treasure", text )

    -- проверка, какой тип тайника выбран
    -- если тайник не классический и не именной, то заменим содержимое
    if amk.load_variable( "option_treasure", 0 ) ~= 0 and v.named == false then
      v.items = self:give_item_list()
    else
      v.items = parse_spawns(
        utils.cfg_get_string(
          self.ini, "treasure_manager." .. k, "items", nil, true, ""
        )
      )
    end

    --' Сгенерить вещи
    for kk, vv in pairs( v.items ) do
      for i = 1, vv.prob do
        alife():create(
          vv.section, obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id,
          obj.id
        )
      end
    end

    --' Пометим тайник как выданный
    self.treasure_info[ k ].active = true
    self.treasure_info[ k ].done   = true
    -- Отправим тайник в оффлайн
    local sim = alife ()
    if sim and obj.online then
      sim:set_switch_online( obj.id, false )
      sim:set_switch_offline( obj.id, true )
      amk.convert_npc[ obj.id ] = 1 -- ставим в очередь на вывод в онлайн
    end
  else
    log2( "TREASURE %s, target doesnt exist", k )
  end
end


--' Снимаем отметку с тайника
function CTreasure:treasure_empty( box, box_story_id )
  local k = self.treasure_by_target[ box_story_id ]
  if k == nil or self.treasure_info[ k ] == nil then 
    return
  end
  self.treasure_info[ k ].active = false
  -- если тайник не именной, то переведен его в онлайн для следующей выдачи
  if self.treasure_info[ k ].named == false then
    self.treasure_info[ k ].done = false
  end
  dsh.map_remove_treasure( box:id(), "treasure" )
end


--' Сохранение
local dsh_save_var_name = "treasure_manager.treasure_info"
function CTreasure:save( p )
  if not db.op2_save_compat then
    p = net_packet()
    p:w_begin( 123 )
    p:r_seek( 2 )
  end
  --' Сохраняем размер таблицы
  local size = 0
  for k, v in pairs( self.treasure_info ) do
    -- пишем состояние только активных тайников
    if v.active or v.done then
      size = size + 1
    end
  end
  p:w_u16( size )
  for k, v in pairs( self.treasure_info ) do
    if v.active or v.done then
      p:w_u16( v.target )
      p:w_bool( v.active )
      p:w_bool( v.done )
    end
  end
  if not db.op2_save_compat then
    ogse.save_var( dsh_save_var_name, p, "chunk")
  end
end


--' Загрузка
function CTreasure:load( p )
  if ogse.var_exists( dsh_save_var_name ) then
    p = ogse.load_var( dsh_save_var_name )
  end
  local t = p:r_u16()
  for i = 1, t do
    local k = self.treasure_by_target[ p:r_u16() ]
    self.treasure_info[ k ].active = p:r_bool()
    self.treasure_info[ k ].done   = p:r_bool()
  end
end


function CTreasure:give_item_list()

 local rank = 1
 local tabla = {}
 -- сколько наименований предметов будет в тайнике
 local i = math.random(1, 4)


-- считаем настройку пользователя 
 local opt = amk.load_variable("option_treasure", 0)
 
  --~ -- определим ранг непися
 --~ if nepis~= nil then
--   rank = n_rank --nepis.character_rank ()
   if n_rank == nil then n_rank = math.random(1, 12)*100 end
   if n_rank <= 300 then
     rank = 1
	elseif n_rank <=600 then
     rank = 2
    elseif n_rank <= 900 then
     rank = 3
    else 
     rank = 4
    end	 
 --~ else
   --~ rank = 1
 --~ end


 for j = 1, i, 1 do
   local cnt = 0
   local spawn = {}
  -- определим, из какой секции брать предметы, и какие именно  
   if  opt == 1 then
		if rank == 1 then
			spawn.section = solid_list.novice_section[math.random(table.getn(solid_list.novice_section))]
		elseif rank == 2 then
			spawn.section = solid_list.experienced_section[math.random(table.getn(solid_list.experienced_section))]
		elseif rank == 3 then
			spawn.section = solid_list.veteran_section[math.random(table.getn(solid_list.veteran_section))]
		else
			spawn.section = solid_list.master_section[math.random(table.getn(solid_list.master_section))]
		end
   else
		if rank == 1 then
			spawn.section = rare_list.novice_section[math.random(table.getn(rare_list.novice_section))]
		elseif rank == 2 then
			spawn.section = rare_list.experienced_section[math.random(table.getn(rare_list.experienced_section))]
		elseif rank == 3 then
			spawn.section = rare_list.veteran_section[math.random(table.getn(rare_list.veteran_section))]
		else
			spawn.section = rare_list.master_section[math.random(table.getn(rare_list.master_section))]
		end
   end	 
  
	-- установка кол-ва предметов в зависимости от секции  
	local s = tostring(spawn.section)
	local cls = system_ini():r_string(s, "class")
	if ammo_section(s) == true then
		-- патроны
		cnt = math.random(1,3)
	elseif cls == "E_STLK" or cls == "W_SILENC" or cls == "W_GLAUNC" or string.find(cls, "WP_") then
		-- броники, оружие
		cnt = 1
	elseif string.find(s, "af") ~= nil or string.find(s, "mutant") ~= nil then
		cnt = math.random(1,2)
	else 
		cnt = math.random(1,5)
	end
  
  -- сохраняем инфу о текущем предмете
  spawn.prob = cnt
  table.insert(tabla, spawn)
 end
 return tabla
end

function get_treasure_manager()
	if treasure_manager == nil then
		treasure_manager = CTreasure()
	end
	return treasure_manager
end

function take_item_from_box(box, box_story_id)
	printf("!!! take item from box %s", tostring(box:is_inv_box_empty()))
--	if box:is_inv_box_empty() == true then
		get_treasure_manager():treasure_empty(box, box_story_id)
--	end
end

function save(p)
	get_treasure_manager():save(p)
end
function load(p)
	get_treasure_manager():load(p)
end
function clear_treasure_manager()
	treasure_manager = nil
end


function CTreasure:dialog( npc )
  if npc then
    n_rank = npc:character_rank()
  else
    n_rank = 0
  end

  local avail  = {}
  local tr_sum = 0
  local treasure_prob

  for k, v in pairs( self.treasure_info ) do
    if v.done == false and v.active == false then
      treasure_prob = xr_logic.pick_section_from_condlist(
        db.actor, npc, xr_logic.parse_condlist(
          db.actor, "treasure_manager", "condlist",
          utils.cfg_get_string(
            self.ini, "treasure_manager." .. k, "condlist", nil, true, ""
          )
        )
      )
      if treasure_prob == "" or treasure_prob == nil then
        treasure_prob = 0
      end
      if tonumber( treasure_prob ) >= 0 and v.active == false then
        if tonumber( treasure_prob ) == 100 then
          self:give_treasure( k )
        else
          table.insert( avail, { k = k, prob = treasure_prob } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end

  if tr_sum == 0 then
    return
  end
  local tr_w = math.random( tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      self:give_treasure( v.k )
      break
    end
  end
end
